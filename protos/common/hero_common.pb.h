// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/hero_common.proto

#ifndef PROTOBUF_common_2fhero_5fcommon_2eproto__INCLUDED
#define PROTOBUF_common_2fhero_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "skill_common.pb.h"
#include "item_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protos {
namespace common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2fhero_5fcommon_2eproto();
void protobuf_AssignDesc_common_2fhero_5fcommon_2eproto();
void protobuf_ShutdownFile_common_2fhero_5fcommon_2eproto();

class Hero;

// ===================================================================

class Hero : public ::google::protobuf::Message {
 public:
  Hero();
  virtual ~Hero();

  Hero(const Hero& from);

  inline Hero& operator=(const Hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hero& default_instance();

  void Swap(Hero* other);

  // implements Message ----------------------------------------------

  Hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hero& from);
  void MergeFrom(const Hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 heroId = 2;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 2;
  inline ::google::protobuf::int32 heroid() const;
  inline void set_heroid(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 maxLevel = 5;
  inline bool has_maxlevel() const;
  inline void clear_maxlevel();
  static const int kMaxLevelFieldNumber = 5;
  inline ::google::protobuf::int32 maxlevel() const;
  inline void set_maxlevel(::google::protobuf::int32 value);

  // optional int32 coldDown = 6;
  inline bool has_colddown() const;
  inline void clear_colddown();
  static const int kColdDownFieldNumber = 6;
  inline ::google::protobuf::int32 colddown() const;
  inline void set_colddown(::google::protobuf::int32 value);

  // optional float atkInterval = 7;
  inline bool has_atkinterval() const;
  inline void clear_atkinterval();
  static const int kAtkIntervalFieldNumber = 7;
  inline float atkinterval() const;
  inline void set_atkinterval(float value);

  // optional int32 hp = 8;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 8;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 atk = 9;
  inline bool has_atk() const;
  inline void clear_atk();
  static const int kAtkFieldNumber = 9;
  inline ::google::protobuf::int32 atk() const;
  inline void set_atk(::google::protobuf::int32 value);

  // optional int32 def = 10;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDefFieldNumber = 10;
  inline ::google::protobuf::int32 def() const;
  inline void set_def(::google::protobuf::int32 value);

  // optional int32 crit = 11;
  inline bool has_crit() const;
  inline void clear_crit();
  static const int kCritFieldNumber = 11;
  inline ::google::protobuf::int32 crit() const;
  inline void set_crit(::google::protobuf::int32 value);

  // optional int32 hit = 12;
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHitFieldNumber = 12;
  inline ::google::protobuf::int32 hit() const;
  inline void set_hit(::google::protobuf::int32 value);

  // optional int32 dodge = 13;
  inline bool has_dodge() const;
  inline void clear_dodge();
  static const int kDodgeFieldNumber = 13;
  inline ::google::protobuf::int32 dodge() const;
  inline void set_dodge(::google::protobuf::int32 value);

  // optional int32 renew = 14;
  inline bool has_renew() const;
  inline void clear_renew();
  static const int kRenewFieldNumber = 14;
  inline ::google::protobuf::int32 renew() const;
  inline void set_renew(::google::protobuf::int32 value);

  // optional int32 dex = 62;
  inline bool has_dex() const;
  inline void clear_dex();
  static const int kDexFieldNumber = 62;
  inline ::google::protobuf::int32 dex() const;
  inline void set_dex(::google::protobuf::int32 value);

  // optional int32 addHp = 15;
  inline bool has_addhp() const;
  inline void clear_addhp();
  static const int kAddHpFieldNumber = 15;
  inline ::google::protobuf::int32 addhp() const;
  inline void set_addhp(::google::protobuf::int32 value);

  // optional int32 addAtk = 16;
  inline bool has_addatk() const;
  inline void clear_addatk();
  static const int kAddAtkFieldNumber = 16;
  inline ::google::protobuf::int32 addatk() const;
  inline void set_addatk(::google::protobuf::int32 value);

  // optional int32 addDef = 17;
  inline bool has_adddef() const;
  inline void clear_adddef();
  static const int kAddDefFieldNumber = 17;
  inline ::google::protobuf::int32 adddef() const;
  inline void set_adddef(::google::protobuf::int32 value);

  // optional int32 addHit = 18;
  inline bool has_addhit() const;
  inline void clear_addhit();
  static const int kAddHitFieldNumber = 18;
  inline ::google::protobuf::int32 addhit() const;
  inline void set_addhit(::google::protobuf::int32 value);

  // optional int32 addCrit = 19;
  inline bool has_addcrit() const;
  inline void clear_addcrit();
  static const int kAddCritFieldNumber = 19;
  inline ::google::protobuf::int32 addcrit() const;
  inline void set_addcrit(::google::protobuf::int32 value);

  // optional int32 addDodge = 20;
  inline bool has_adddodge() const;
  inline void clear_adddodge();
  static const int kAddDodgeFieldNumber = 20;
  inline ::google::protobuf::int32 adddodge() const;
  inline void set_adddodge(::google::protobuf::int32 value);

  // optional int32 addRenew = 21;
  inline bool has_addrenew() const;
  inline void clear_addrenew();
  static const int kAddRenewFieldNumber = 21;
  inline ::google::protobuf::int32 addrenew() const;
  inline void set_addrenew(::google::protobuf::int32 value);

  // optional int32 addDex = 63;
  inline bool has_adddex() const;
  inline void clear_adddex();
  static const int kAddDexFieldNumber = 63;
  inline ::google::protobuf::int32 adddex() const;
  inline void set_adddex(::google::protobuf::int32 value);

  // optional int32 initCost = 22;
  inline bool has_initcost() const;
  inline void clear_initcost();
  static const int kInitCostFieldNumber = 22;
  inline ::google::protobuf::int32 initcost() const;
  inline void set_initcost(::google::protobuf::int32 value);

  // optional int32 useCost = 23;
  inline bool has_usecost() const;
  inline void clear_usecost();
  static const int kUseCostFieldNumber = 23;
  inline ::google::protobuf::int32 usecost() const;
  inline void set_usecost(::google::protobuf::int32 value);

  // optional float addCost = 24;
  inline bool has_addcost() const;
  inline void clear_addcost();
  static const int kAddCostFieldNumber = 24;
  inline float addcost() const;
  inline void set_addcost(float value);

  // optional int32 moveCost = 25;
  inline bool has_movecost() const;
  inline void clear_movecost();
  static const int kMoveCostFieldNumber = 25;
  inline ::google::protobuf::int32 movecost() const;
  inline void set_movecost(::google::protobuf::int32 value);

  // optional int32 maxCost = 26;
  inline bool has_maxcost() const;
  inline void clear_maxcost();
  static const int kMaxCostFieldNumber = 26;
  inline ::google::protobuf::int32 maxcost() const;
  inline void set_maxcost(::google::protobuf::int32 value);

  // optional int32 exp = 27;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 27;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 nextExp = 28;
  inline bool has_nextexp() const;
  inline void clear_nextexp();
  static const int kNextExpFieldNumber = 28;
  inline ::google::protobuf::int32 nextexp() const;
  inline void set_nextexp(::google::protobuf::int32 value);

  // optional int32 heroType = 29;
  inline bool has_herotype() const;
  inline void clear_herotype();
  static const int kHeroTypeFieldNumber = 29;
  inline ::google::protobuf::int32 herotype() const;
  inline void set_herotype(::google::protobuf::int32 value);

  // optional int32 thumb = 30;
  inline bool has_thumb() const;
  inline void clear_thumb();
  static const int kThumbFieldNumber = 30;
  inline ::google::protobuf::int32 thumb() const;
  inline void set_thumb(::google::protobuf::int32 value);

  // optional int32 zoom = 31;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 31;
  inline ::google::protobuf::int32 zoom() const;
  inline void set_zoom(::google::protobuf::int32 value);

  // optional int32 quality = 32;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 32;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 maxQuality = 33;
  inline bool has_maxquality() const;
  inline void clear_maxquality();
  static const int kMaxQualityFieldNumber = 33;
  inline ::google::protobuf::int32 maxquality() const;
  inline void set_maxquality(::google::protobuf::int32 value);

  // optional int32 itemId = 37;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 37;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 itemNum1 = 34;
  inline bool has_itemnum1() const;
  inline void clear_itemnum1();
  static const int kItemNum1FieldNumber = 34;
  inline ::google::protobuf::int32 itemnum1() const;
  inline void set_itemnum1(::google::protobuf::int32 value);

  // optional int32 itemNum2 = 35;
  inline bool has_itemnum2() const;
  inline void clear_itemnum2();
  static const int kItemNum2FieldNumber = 35;
  inline ::google::protobuf::int32 itemnum2() const;
  inline void set_itemnum2(::google::protobuf::int32 value);

  // optional bool own = 36;
  inline bool has_own() const;
  inline void clear_own();
  static const int kOwnFieldNumber = 36;
  inline bool own() const;
  inline void set_own(bool value);

  // optional int32 alert = 38;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 38;
  inline ::google::protobuf::int32 alert() const;
  inline void set_alert(::google::protobuf::int32 value);

  // optional int32 alertRange = 39;
  inline bool has_alertrange() const;
  inline void clear_alertrange();
  static const int kAlertRangeFieldNumber = 39;
  inline ::google::protobuf::int32 alertrange() const;
  inline void set_alertrange(::google::protobuf::int32 value);

  // optional int32 posX = 40;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosXFieldNumber = 40;
  inline ::google::protobuf::int32 posx() const;
  inline void set_posx(::google::protobuf::int32 value);

  // optional int32 posY = 41;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosYFieldNumber = 41;
  inline ::google::protobuf::int32 posy() const;
  inline void set_posy(::google::protobuf::int32 value);

  // optional float moveSpeed = 64;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMoveSpeedFieldNumber = 64;
  inline float movespeed() const;
  inline void set_movespeed(float value);

  // optional .protos.common.Skill skill1 = 42;
  inline bool has_skill1() const;
  inline void clear_skill1();
  static const int kSkill1FieldNumber = 42;
  inline const ::protos::common::Skill& skill1() const;
  inline ::protos::common::Skill* mutable_skill1();
  inline ::protos::common::Skill* release_skill1();
  inline void set_allocated_skill1(::protos::common::Skill* skill1);

  // optional .protos.common.Skill skill2 = 43;
  inline bool has_skill2() const;
  inline void clear_skill2();
  static const int kSkill2FieldNumber = 43;
  inline const ::protos::common::Skill& skill2() const;
  inline ::protos::common::Skill* mutable_skill2();
  inline ::protos::common::Skill* release_skill2();
  inline void set_allocated_skill2(::protos::common::Skill* skill2);

  // optional .protos.common.Skill skill3 = 44;
  inline bool has_skill3() const;
  inline void clear_skill3();
  static const int kSkill3FieldNumber = 44;
  inline const ::protos::common::Skill& skill3() const;
  inline ::protos::common::Skill* mutable_skill3();
  inline ::protos::common::Skill* release_skill3();
  inline void set_allocated_skill3(::protos::common::Skill* skill3);

  // optional .protos.common.Skill skill4 = 45;
  inline bool has_skill4() const;
  inline void clear_skill4();
  static const int kSkill4FieldNumber = 45;
  inline const ::protos::common::Skill& skill4() const;
  inline ::protos::common::Skill* mutable_skill4();
  inline ::protos::common::Skill* release_skill4();
  inline void set_allocated_skill4(::protos::common::Skill* skill4);

  // optional .protos.common.Skill skill5 = 65;
  inline bool has_skill5() const;
  inline void clear_skill5();
  static const int kSkill5FieldNumber = 65;
  inline const ::protos::common::Skill& skill5() const;
  inline ::protos::common::Skill* mutable_skill5();
  inline ::protos::common::Skill* release_skill5();
  inline void set_allocated_skill5(::protos::common::Skill* skill5);

  // optional int32 combat = 46;
  inline bool has_combat() const;
  inline void clear_combat();
  static const int kCombatFieldNumber = 46;
  inline ::google::protobuf::int32 combat() const;
  inline void set_combat(::google::protobuf::int32 value);

  // optional int32 coin = 49;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 49;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional .protos.common.Item armor1 = 51;
  inline bool has_armor1() const;
  inline void clear_armor1();
  static const int kArmor1FieldNumber = 51;
  inline const ::protos::common::Item& armor1() const;
  inline ::protos::common::Item* mutable_armor1();
  inline ::protos::common::Item* release_armor1();
  inline void set_allocated_armor1(::protos::common::Item* armor1);

  // optional .protos.common.Item armor2 = 52;
  inline bool has_armor2() const;
  inline void clear_armor2();
  static const int kArmor2FieldNumber = 52;
  inline const ::protos::common::Item& armor2() const;
  inline ::protos::common::Item* mutable_armor2();
  inline ::protos::common::Item* release_armor2();
  inline void set_allocated_armor2(::protos::common::Item* armor2);

  // optional .protos.common.Item armor3 = 48;
  inline bool has_armor3() const;
  inline void clear_armor3();
  static const int kArmor3FieldNumber = 48;
  inline const ::protos::common::Item& armor3() const;
  inline ::protos::common::Item* mutable_armor3();
  inline ::protos::common::Item* release_armor3();
  inline void set_allocated_armor3(::protos::common::Item* armor3);

  // optional .protos.common.Item armor4 = 50;
  inline bool has_armor4() const;
  inline void clear_armor4();
  static const int kArmor4FieldNumber = 50;
  inline const ::protos::common::Item& armor4() const;
  inline ::protos::common::Item* mutable_armor4();
  inline ::protos::common::Item* release_armor4();
  inline void set_allocated_armor4(::protos::common::Item* armor4);

  // optional .protos.common.Item armor5 = 53;
  inline bool has_armor5() const;
  inline void clear_armor5();
  static const int kArmor5FieldNumber = 53;
  inline const ::protos::common::Item& armor5() const;
  inline ::protos::common::Item* mutable_armor5();
  inline ::protos::common::Item* release_armor5();
  inline void set_allocated_armor5(::protos::common::Item* armor5);

  // optional int32 prate = 54;
  inline bool has_prate() const;
  inline void clear_prate();
  static const int kPrateFieldNumber = 54;
  inline ::google::protobuf::int32 prate() const;
  inline void set_prate(::google::protobuf::int32 value);

  // optional bool battle = 55;
  inline bool has_battle() const;
  inline void clear_battle();
  static const int kBattleFieldNumber = 55;
  inline bool battle() const;
  inline void set_battle(bool value);

  // optional bool remove = 56;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 56;
  inline bool remove() const;
  inline void set_remove(bool value);

  // optional int32 color = 47;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 47;
  inline ::google::protobuf::int32 color() const;
  inline void set_color(::google::protobuf::int32 value);

  // optional bool evol = 57;
  inline bool has_evol() const;
  inline void clear_evol();
  static const int kEvolFieldNumber = 57;
  inline bool evol() const;
  inline void set_evol(bool value);

  // @@protoc_insertion_point(class_scope:protos.common.Hero)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_maxlevel();
  inline void clear_has_maxlevel();
  inline void set_has_colddown();
  inline void clear_has_colddown();
  inline void set_has_atkinterval();
  inline void clear_has_atkinterval();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_atk();
  inline void clear_has_atk();
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_crit();
  inline void clear_has_crit();
  inline void set_has_hit();
  inline void clear_has_hit();
  inline void set_has_dodge();
  inline void clear_has_dodge();
  inline void set_has_renew();
  inline void clear_has_renew();
  inline void set_has_dex();
  inline void clear_has_dex();
  inline void set_has_addhp();
  inline void clear_has_addhp();
  inline void set_has_addatk();
  inline void clear_has_addatk();
  inline void set_has_adddef();
  inline void clear_has_adddef();
  inline void set_has_addhit();
  inline void clear_has_addhit();
  inline void set_has_addcrit();
  inline void clear_has_addcrit();
  inline void set_has_adddodge();
  inline void clear_has_adddodge();
  inline void set_has_addrenew();
  inline void clear_has_addrenew();
  inline void set_has_adddex();
  inline void clear_has_adddex();
  inline void set_has_initcost();
  inline void clear_has_initcost();
  inline void set_has_usecost();
  inline void clear_has_usecost();
  inline void set_has_addcost();
  inline void clear_has_addcost();
  inline void set_has_movecost();
  inline void clear_has_movecost();
  inline void set_has_maxcost();
  inline void clear_has_maxcost();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_nextexp();
  inline void clear_has_nextexp();
  inline void set_has_herotype();
  inline void clear_has_herotype();
  inline void set_has_thumb();
  inline void clear_has_thumb();
  inline void set_has_zoom();
  inline void clear_has_zoom();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_maxquality();
  inline void clear_has_maxquality();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum1();
  inline void clear_has_itemnum1();
  inline void set_has_itemnum2();
  inline void clear_has_itemnum2();
  inline void set_has_own();
  inline void clear_has_own();
  inline void set_has_alert();
  inline void clear_has_alert();
  inline void set_has_alertrange();
  inline void clear_has_alertrange();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_skill1();
  inline void clear_has_skill1();
  inline void set_has_skill2();
  inline void clear_has_skill2();
  inline void set_has_skill3();
  inline void clear_has_skill3();
  inline void set_has_skill4();
  inline void clear_has_skill4();
  inline void set_has_skill5();
  inline void clear_has_skill5();
  inline void set_has_combat();
  inline void clear_has_combat();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_armor1();
  inline void clear_has_armor1();
  inline void set_has_armor2();
  inline void clear_has_armor2();
  inline void set_has_armor3();
  inline void clear_has_armor3();
  inline void set_has_armor4();
  inline void clear_has_armor4();
  inline void set_has_armor5();
  inline void clear_has_armor5();
  inline void set_has_prate();
  inline void clear_has_prate();
  inline void set_has_battle();
  inline void clear_has_battle();
  inline void set_has_remove();
  inline void clear_has_remove();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_evol();
  inline void clear_has_evol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 heroid_;
  ::std::string* name_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maxlevel_;
  ::google::protobuf::int32 colddown_;
  float atkinterval_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 atk_;
  ::google::protobuf::int32 def_;
  ::google::protobuf::int32 crit_;
  ::google::protobuf::int32 hit_;
  ::google::protobuf::int32 dodge_;
  ::google::protobuf::int32 renew_;
  ::google::protobuf::int32 dex_;
  ::google::protobuf::int32 addhp_;
  ::google::protobuf::int32 addatk_;
  ::google::protobuf::int32 adddef_;
  ::google::protobuf::int32 addhit_;
  ::google::protobuf::int32 addcrit_;
  ::google::protobuf::int32 adddodge_;
  ::google::protobuf::int32 addrenew_;
  ::google::protobuf::int32 adddex_;
  ::google::protobuf::int32 initcost_;
  ::google::protobuf::int32 usecost_;
  float addcost_;
  ::google::protobuf::int32 movecost_;
  ::google::protobuf::int32 maxcost_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 nextexp_;
  ::google::protobuf::int32 herotype_;
  ::google::protobuf::int32 thumb_;
  ::google::protobuf::int32 zoom_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 maxquality_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itemnum1_;
  ::google::protobuf::int32 itemnum2_;
  ::google::protobuf::int32 alert_;
  ::google::protobuf::int32 alertrange_;
  ::google::protobuf::int32 posx_;
  ::google::protobuf::int32 posy_;
  float movespeed_;
  ::protos::common::Skill* skill1_;
  ::protos::common::Skill* skill2_;
  ::protos::common::Skill* skill3_;
  ::protos::common::Skill* skill4_;
  ::protos::common::Skill* skill5_;
  ::google::protobuf::int32 combat_;
  ::google::protobuf::int32 coin_;
  ::protos::common::Item* armor1_;
  ::protos::common::Item* armor2_;
  ::protos::common::Item* armor3_;
  bool own_;
  bool battle_;
  bool remove_;
  bool evol_;
  ::google::protobuf::int32 prate_;
  ::protos::common::Item* armor4_;
  ::protos::common::Item* armor5_;
  ::google::protobuf::int32 color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(61 + 31) / 32];

  friend void  protobuf_AddDesc_common_2fhero_5fcommon_2eproto();
  friend void protobuf_AssignDesc_common_2fhero_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_common_2fhero_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static Hero* default_instance_;
};
// ===================================================================


// ===================================================================

// Hero

// optional int32 id = 1;
inline bool Hero::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hero::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hero::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hero::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Hero::id() const {
  return id_;
}
inline void Hero::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 heroId = 2;
inline bool Hero::has_heroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hero::set_has_heroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hero::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hero::clear_heroid() {
  heroid_ = 0;
  clear_has_heroid();
}
inline ::google::protobuf::int32 Hero::heroid() const {
  return heroid_;
}
inline void Hero::set_heroid(::google::protobuf::int32 value) {
  set_has_heroid();
  heroid_ = value;
}

// optional string name = 3;
inline bool Hero::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hero::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hero::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hero::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Hero::name() const {
  return *name_;
}
inline void Hero::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Hero::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Hero::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hero::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Hero::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hero::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 4;
inline bool Hero::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hero::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hero::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hero::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Hero::level() const {
  return level_;
}
inline void Hero::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 maxLevel = 5;
inline bool Hero::has_maxlevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hero::set_has_maxlevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hero::clear_has_maxlevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hero::clear_maxlevel() {
  maxlevel_ = 0;
  clear_has_maxlevel();
}
inline ::google::protobuf::int32 Hero::maxlevel() const {
  return maxlevel_;
}
inline void Hero::set_maxlevel(::google::protobuf::int32 value) {
  set_has_maxlevel();
  maxlevel_ = value;
}

// optional int32 coldDown = 6;
inline bool Hero::has_colddown() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hero::set_has_colddown() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hero::clear_has_colddown() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hero::clear_colddown() {
  colddown_ = 0;
  clear_has_colddown();
}
inline ::google::protobuf::int32 Hero::colddown() const {
  return colddown_;
}
inline void Hero::set_colddown(::google::protobuf::int32 value) {
  set_has_colddown();
  colddown_ = value;
}

// optional float atkInterval = 7;
inline bool Hero::has_atkinterval() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Hero::set_has_atkinterval() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Hero::clear_has_atkinterval() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Hero::clear_atkinterval() {
  atkinterval_ = 0;
  clear_has_atkinterval();
}
inline float Hero::atkinterval() const {
  return atkinterval_;
}
inline void Hero::set_atkinterval(float value) {
  set_has_atkinterval();
  atkinterval_ = value;
}

// optional int32 hp = 8;
inline bool Hero::has_hp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Hero::set_has_hp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Hero::clear_has_hp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Hero::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Hero::hp() const {
  return hp_;
}
inline void Hero::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 atk = 9;
inline bool Hero::has_atk() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Hero::set_has_atk() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Hero::clear_has_atk() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Hero::clear_atk() {
  atk_ = 0;
  clear_has_atk();
}
inline ::google::protobuf::int32 Hero::atk() const {
  return atk_;
}
inline void Hero::set_atk(::google::protobuf::int32 value) {
  set_has_atk();
  atk_ = value;
}

// optional int32 def = 10;
inline bool Hero::has_def() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Hero::set_has_def() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Hero::clear_has_def() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Hero::clear_def() {
  def_ = 0;
  clear_has_def();
}
inline ::google::protobuf::int32 Hero::def() const {
  return def_;
}
inline void Hero::set_def(::google::protobuf::int32 value) {
  set_has_def();
  def_ = value;
}

// optional int32 crit = 11;
inline bool Hero::has_crit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Hero::set_has_crit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Hero::clear_has_crit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Hero::clear_crit() {
  crit_ = 0;
  clear_has_crit();
}
inline ::google::protobuf::int32 Hero::crit() const {
  return crit_;
}
inline void Hero::set_crit(::google::protobuf::int32 value) {
  set_has_crit();
  crit_ = value;
}

// optional int32 hit = 12;
inline bool Hero::has_hit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Hero::set_has_hit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Hero::clear_has_hit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Hero::clear_hit() {
  hit_ = 0;
  clear_has_hit();
}
inline ::google::protobuf::int32 Hero::hit() const {
  return hit_;
}
inline void Hero::set_hit(::google::protobuf::int32 value) {
  set_has_hit();
  hit_ = value;
}

// optional int32 dodge = 13;
inline bool Hero::has_dodge() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Hero::set_has_dodge() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Hero::clear_has_dodge() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Hero::clear_dodge() {
  dodge_ = 0;
  clear_has_dodge();
}
inline ::google::protobuf::int32 Hero::dodge() const {
  return dodge_;
}
inline void Hero::set_dodge(::google::protobuf::int32 value) {
  set_has_dodge();
  dodge_ = value;
}

// optional int32 renew = 14;
inline bool Hero::has_renew() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Hero::set_has_renew() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Hero::clear_has_renew() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Hero::clear_renew() {
  renew_ = 0;
  clear_has_renew();
}
inline ::google::protobuf::int32 Hero::renew() const {
  return renew_;
}
inline void Hero::set_renew(::google::protobuf::int32 value) {
  set_has_renew();
  renew_ = value;
}

// optional int32 dex = 62;
inline bool Hero::has_dex() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Hero::set_has_dex() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Hero::clear_has_dex() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Hero::clear_dex() {
  dex_ = 0;
  clear_has_dex();
}
inline ::google::protobuf::int32 Hero::dex() const {
  return dex_;
}
inline void Hero::set_dex(::google::protobuf::int32 value) {
  set_has_dex();
  dex_ = value;
}

// optional int32 addHp = 15;
inline bool Hero::has_addhp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Hero::set_has_addhp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Hero::clear_has_addhp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Hero::clear_addhp() {
  addhp_ = 0;
  clear_has_addhp();
}
inline ::google::protobuf::int32 Hero::addhp() const {
  return addhp_;
}
inline void Hero::set_addhp(::google::protobuf::int32 value) {
  set_has_addhp();
  addhp_ = value;
}

// optional int32 addAtk = 16;
inline bool Hero::has_addatk() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Hero::set_has_addatk() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Hero::clear_has_addatk() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Hero::clear_addatk() {
  addatk_ = 0;
  clear_has_addatk();
}
inline ::google::protobuf::int32 Hero::addatk() const {
  return addatk_;
}
inline void Hero::set_addatk(::google::protobuf::int32 value) {
  set_has_addatk();
  addatk_ = value;
}

// optional int32 addDef = 17;
inline bool Hero::has_adddef() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Hero::set_has_adddef() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Hero::clear_has_adddef() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Hero::clear_adddef() {
  adddef_ = 0;
  clear_has_adddef();
}
inline ::google::protobuf::int32 Hero::adddef() const {
  return adddef_;
}
inline void Hero::set_adddef(::google::protobuf::int32 value) {
  set_has_adddef();
  adddef_ = value;
}

// optional int32 addHit = 18;
inline bool Hero::has_addhit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Hero::set_has_addhit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Hero::clear_has_addhit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Hero::clear_addhit() {
  addhit_ = 0;
  clear_has_addhit();
}
inline ::google::protobuf::int32 Hero::addhit() const {
  return addhit_;
}
inline void Hero::set_addhit(::google::protobuf::int32 value) {
  set_has_addhit();
  addhit_ = value;
}

// optional int32 addCrit = 19;
inline bool Hero::has_addcrit() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Hero::set_has_addcrit() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Hero::clear_has_addcrit() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Hero::clear_addcrit() {
  addcrit_ = 0;
  clear_has_addcrit();
}
inline ::google::protobuf::int32 Hero::addcrit() const {
  return addcrit_;
}
inline void Hero::set_addcrit(::google::protobuf::int32 value) {
  set_has_addcrit();
  addcrit_ = value;
}

// optional int32 addDodge = 20;
inline bool Hero::has_adddodge() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Hero::set_has_adddodge() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Hero::clear_has_adddodge() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Hero::clear_adddodge() {
  adddodge_ = 0;
  clear_has_adddodge();
}
inline ::google::protobuf::int32 Hero::adddodge() const {
  return adddodge_;
}
inline void Hero::set_adddodge(::google::protobuf::int32 value) {
  set_has_adddodge();
  adddodge_ = value;
}

// optional int32 addRenew = 21;
inline bool Hero::has_addrenew() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Hero::set_has_addrenew() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Hero::clear_has_addrenew() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Hero::clear_addrenew() {
  addrenew_ = 0;
  clear_has_addrenew();
}
inline ::google::protobuf::int32 Hero::addrenew() const {
  return addrenew_;
}
inline void Hero::set_addrenew(::google::protobuf::int32 value) {
  set_has_addrenew();
  addrenew_ = value;
}

// optional int32 addDex = 63;
inline bool Hero::has_adddex() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Hero::set_has_adddex() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Hero::clear_has_adddex() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Hero::clear_adddex() {
  adddex_ = 0;
  clear_has_adddex();
}
inline ::google::protobuf::int32 Hero::adddex() const {
  return adddex_;
}
inline void Hero::set_adddex(::google::protobuf::int32 value) {
  set_has_adddex();
  adddex_ = value;
}

// optional int32 initCost = 22;
inline bool Hero::has_initcost() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Hero::set_has_initcost() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Hero::clear_has_initcost() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Hero::clear_initcost() {
  initcost_ = 0;
  clear_has_initcost();
}
inline ::google::protobuf::int32 Hero::initcost() const {
  return initcost_;
}
inline void Hero::set_initcost(::google::protobuf::int32 value) {
  set_has_initcost();
  initcost_ = value;
}

// optional int32 useCost = 23;
inline bool Hero::has_usecost() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Hero::set_has_usecost() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Hero::clear_has_usecost() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Hero::clear_usecost() {
  usecost_ = 0;
  clear_has_usecost();
}
inline ::google::protobuf::int32 Hero::usecost() const {
  return usecost_;
}
inline void Hero::set_usecost(::google::protobuf::int32 value) {
  set_has_usecost();
  usecost_ = value;
}

// optional float addCost = 24;
inline bool Hero::has_addcost() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Hero::set_has_addcost() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Hero::clear_has_addcost() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Hero::clear_addcost() {
  addcost_ = 0;
  clear_has_addcost();
}
inline float Hero::addcost() const {
  return addcost_;
}
inline void Hero::set_addcost(float value) {
  set_has_addcost();
  addcost_ = value;
}

// optional int32 moveCost = 25;
inline bool Hero::has_movecost() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Hero::set_has_movecost() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Hero::clear_has_movecost() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Hero::clear_movecost() {
  movecost_ = 0;
  clear_has_movecost();
}
inline ::google::protobuf::int32 Hero::movecost() const {
  return movecost_;
}
inline void Hero::set_movecost(::google::protobuf::int32 value) {
  set_has_movecost();
  movecost_ = value;
}

// optional int32 maxCost = 26;
inline bool Hero::has_maxcost() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Hero::set_has_maxcost() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Hero::clear_has_maxcost() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Hero::clear_maxcost() {
  maxcost_ = 0;
  clear_has_maxcost();
}
inline ::google::protobuf::int32 Hero::maxcost() const {
  return maxcost_;
}
inline void Hero::set_maxcost(::google::protobuf::int32 value) {
  set_has_maxcost();
  maxcost_ = value;
}

// optional int32 exp = 27;
inline bool Hero::has_exp() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Hero::set_has_exp() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Hero::clear_has_exp() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Hero::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 Hero::exp() const {
  return exp_;
}
inline void Hero::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 nextExp = 28;
inline bool Hero::has_nextexp() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Hero::set_has_nextexp() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Hero::clear_has_nextexp() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Hero::clear_nextexp() {
  nextexp_ = 0;
  clear_has_nextexp();
}
inline ::google::protobuf::int32 Hero::nextexp() const {
  return nextexp_;
}
inline void Hero::set_nextexp(::google::protobuf::int32 value) {
  set_has_nextexp();
  nextexp_ = value;
}

// optional int32 heroType = 29;
inline bool Hero::has_herotype() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Hero::set_has_herotype() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Hero::clear_has_herotype() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Hero::clear_herotype() {
  herotype_ = 0;
  clear_has_herotype();
}
inline ::google::protobuf::int32 Hero::herotype() const {
  return herotype_;
}
inline void Hero::set_herotype(::google::protobuf::int32 value) {
  set_has_herotype();
  herotype_ = value;
}

// optional int32 thumb = 30;
inline bool Hero::has_thumb() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Hero::set_has_thumb() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Hero::clear_has_thumb() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Hero::clear_thumb() {
  thumb_ = 0;
  clear_has_thumb();
}
inline ::google::protobuf::int32 Hero::thumb() const {
  return thumb_;
}
inline void Hero::set_thumb(::google::protobuf::int32 value) {
  set_has_thumb();
  thumb_ = value;
}

// optional int32 zoom = 31;
inline bool Hero::has_zoom() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Hero::set_has_zoom() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Hero::clear_has_zoom() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Hero::clear_zoom() {
  zoom_ = 0;
  clear_has_zoom();
}
inline ::google::protobuf::int32 Hero::zoom() const {
  return zoom_;
}
inline void Hero::set_zoom(::google::protobuf::int32 value) {
  set_has_zoom();
  zoom_ = value;
}

// optional int32 quality = 32;
inline bool Hero::has_quality() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Hero::set_has_quality() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Hero::clear_has_quality() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Hero::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 Hero::quality() const {
  return quality_;
}
inline void Hero::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int32 maxQuality = 33;
inline bool Hero::has_maxquality() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Hero::set_has_maxquality() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Hero::clear_has_maxquality() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Hero::clear_maxquality() {
  maxquality_ = 0;
  clear_has_maxquality();
}
inline ::google::protobuf::int32 Hero::maxquality() const {
  return maxquality_;
}
inline void Hero::set_maxquality(::google::protobuf::int32 value) {
  set_has_maxquality();
  maxquality_ = value;
}

// optional int32 itemId = 37;
inline bool Hero::has_itemid() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Hero::set_has_itemid() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Hero::clear_has_itemid() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Hero::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 Hero::itemid() const {
  return itemid_;
}
inline void Hero::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 itemNum1 = 34;
inline bool Hero::has_itemnum1() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Hero::set_has_itemnum1() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Hero::clear_has_itemnum1() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Hero::clear_itemnum1() {
  itemnum1_ = 0;
  clear_has_itemnum1();
}
inline ::google::protobuf::int32 Hero::itemnum1() const {
  return itemnum1_;
}
inline void Hero::set_itemnum1(::google::protobuf::int32 value) {
  set_has_itemnum1();
  itemnum1_ = value;
}

// optional int32 itemNum2 = 35;
inline bool Hero::has_itemnum2() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Hero::set_has_itemnum2() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Hero::clear_has_itemnum2() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Hero::clear_itemnum2() {
  itemnum2_ = 0;
  clear_has_itemnum2();
}
inline ::google::protobuf::int32 Hero::itemnum2() const {
  return itemnum2_;
}
inline void Hero::set_itemnum2(::google::protobuf::int32 value) {
  set_has_itemnum2();
  itemnum2_ = value;
}

// optional bool own = 36;
inline bool Hero::has_own() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Hero::set_has_own() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Hero::clear_has_own() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Hero::clear_own() {
  own_ = false;
  clear_has_own();
}
inline bool Hero::own() const {
  return own_;
}
inline void Hero::set_own(bool value) {
  set_has_own();
  own_ = value;
}

// optional int32 alert = 38;
inline bool Hero::has_alert() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Hero::set_has_alert() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Hero::clear_has_alert() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Hero::clear_alert() {
  alert_ = 0;
  clear_has_alert();
}
inline ::google::protobuf::int32 Hero::alert() const {
  return alert_;
}
inline void Hero::set_alert(::google::protobuf::int32 value) {
  set_has_alert();
  alert_ = value;
}

// optional int32 alertRange = 39;
inline bool Hero::has_alertrange() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Hero::set_has_alertrange() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Hero::clear_has_alertrange() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Hero::clear_alertrange() {
  alertrange_ = 0;
  clear_has_alertrange();
}
inline ::google::protobuf::int32 Hero::alertrange() const {
  return alertrange_;
}
inline void Hero::set_alertrange(::google::protobuf::int32 value) {
  set_has_alertrange();
  alertrange_ = value;
}

// optional int32 posX = 40;
inline bool Hero::has_posx() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Hero::set_has_posx() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Hero::clear_has_posx() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Hero::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline ::google::protobuf::int32 Hero::posx() const {
  return posx_;
}
inline void Hero::set_posx(::google::protobuf::int32 value) {
  set_has_posx();
  posx_ = value;
}

// optional int32 posY = 41;
inline bool Hero::has_posy() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Hero::set_has_posy() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Hero::clear_has_posy() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Hero::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline ::google::protobuf::int32 Hero::posy() const {
  return posy_;
}
inline void Hero::set_posy(::google::protobuf::int32 value) {
  set_has_posy();
  posy_ = value;
}

// optional float moveSpeed = 64;
inline bool Hero::has_movespeed() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Hero::set_has_movespeed() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Hero::clear_has_movespeed() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Hero::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline float Hero::movespeed() const {
  return movespeed_;
}
inline void Hero::set_movespeed(float value) {
  set_has_movespeed();
  movespeed_ = value;
}

// optional .protos.common.Skill skill1 = 42;
inline bool Hero::has_skill1() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Hero::set_has_skill1() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Hero::clear_has_skill1() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Hero::clear_skill1() {
  if (skill1_ != NULL) skill1_->::protos::common::Skill::Clear();
  clear_has_skill1();
}
inline const ::protos::common::Skill& Hero::skill1() const {
  return skill1_ != NULL ? *skill1_ : *default_instance_->skill1_;
}
inline ::protos::common::Skill* Hero::mutable_skill1() {
  set_has_skill1();
  if (skill1_ == NULL) skill1_ = new ::protos::common::Skill;
  return skill1_;
}
inline ::protos::common::Skill* Hero::release_skill1() {
  clear_has_skill1();
  ::protos::common::Skill* temp = skill1_;
  skill1_ = NULL;
  return temp;
}
inline void Hero::set_allocated_skill1(::protos::common::Skill* skill1) {
  delete skill1_;
  skill1_ = skill1;
  if (skill1) {
    set_has_skill1();
  } else {
    clear_has_skill1();
  }
}

// optional .protos.common.Skill skill2 = 43;
inline bool Hero::has_skill2() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Hero::set_has_skill2() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Hero::clear_has_skill2() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void Hero::clear_skill2() {
  if (skill2_ != NULL) skill2_->::protos::common::Skill::Clear();
  clear_has_skill2();
}
inline const ::protos::common::Skill& Hero::skill2() const {
  return skill2_ != NULL ? *skill2_ : *default_instance_->skill2_;
}
inline ::protos::common::Skill* Hero::mutable_skill2() {
  set_has_skill2();
  if (skill2_ == NULL) skill2_ = new ::protos::common::Skill;
  return skill2_;
}
inline ::protos::common::Skill* Hero::release_skill2() {
  clear_has_skill2();
  ::protos::common::Skill* temp = skill2_;
  skill2_ = NULL;
  return temp;
}
inline void Hero::set_allocated_skill2(::protos::common::Skill* skill2) {
  delete skill2_;
  skill2_ = skill2;
  if (skill2) {
    set_has_skill2();
  } else {
    clear_has_skill2();
  }
}

// optional .protos.common.Skill skill3 = 44;
inline bool Hero::has_skill3() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Hero::set_has_skill3() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Hero::clear_has_skill3() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void Hero::clear_skill3() {
  if (skill3_ != NULL) skill3_->::protos::common::Skill::Clear();
  clear_has_skill3();
}
inline const ::protos::common::Skill& Hero::skill3() const {
  return skill3_ != NULL ? *skill3_ : *default_instance_->skill3_;
}
inline ::protos::common::Skill* Hero::mutable_skill3() {
  set_has_skill3();
  if (skill3_ == NULL) skill3_ = new ::protos::common::Skill;
  return skill3_;
}
inline ::protos::common::Skill* Hero::release_skill3() {
  clear_has_skill3();
  ::protos::common::Skill* temp = skill3_;
  skill3_ = NULL;
  return temp;
}
inline void Hero::set_allocated_skill3(::protos::common::Skill* skill3) {
  delete skill3_;
  skill3_ = skill3;
  if (skill3) {
    set_has_skill3();
  } else {
    clear_has_skill3();
  }
}

// optional .protos.common.Skill skill4 = 45;
inline bool Hero::has_skill4() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Hero::set_has_skill4() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Hero::clear_has_skill4() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void Hero::clear_skill4() {
  if (skill4_ != NULL) skill4_->::protos::common::Skill::Clear();
  clear_has_skill4();
}
inline const ::protos::common::Skill& Hero::skill4() const {
  return skill4_ != NULL ? *skill4_ : *default_instance_->skill4_;
}
inline ::protos::common::Skill* Hero::mutable_skill4() {
  set_has_skill4();
  if (skill4_ == NULL) skill4_ = new ::protos::common::Skill;
  return skill4_;
}
inline ::protos::common::Skill* Hero::release_skill4() {
  clear_has_skill4();
  ::protos::common::Skill* temp = skill4_;
  skill4_ = NULL;
  return temp;
}
inline void Hero::set_allocated_skill4(::protos::common::Skill* skill4) {
  delete skill4_;
  skill4_ = skill4;
  if (skill4) {
    set_has_skill4();
  } else {
    clear_has_skill4();
  }
}

// optional .protos.common.Skill skill5 = 65;
inline bool Hero::has_skill5() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Hero::set_has_skill5() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Hero::clear_has_skill5() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Hero::clear_skill5() {
  if (skill5_ != NULL) skill5_->::protos::common::Skill::Clear();
  clear_has_skill5();
}
inline const ::protos::common::Skill& Hero::skill5() const {
  return skill5_ != NULL ? *skill5_ : *default_instance_->skill5_;
}
inline ::protos::common::Skill* Hero::mutable_skill5() {
  set_has_skill5();
  if (skill5_ == NULL) skill5_ = new ::protos::common::Skill;
  return skill5_;
}
inline ::protos::common::Skill* Hero::release_skill5() {
  clear_has_skill5();
  ::protos::common::Skill* temp = skill5_;
  skill5_ = NULL;
  return temp;
}
inline void Hero::set_allocated_skill5(::protos::common::Skill* skill5) {
  delete skill5_;
  skill5_ = skill5;
  if (skill5) {
    set_has_skill5();
  } else {
    clear_has_skill5();
  }
}

// optional int32 combat = 46;
inline bool Hero::has_combat() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void Hero::set_has_combat() {
  _has_bits_[1] |= 0x00020000u;
}
inline void Hero::clear_has_combat() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void Hero::clear_combat() {
  combat_ = 0;
  clear_has_combat();
}
inline ::google::protobuf::int32 Hero::combat() const {
  return combat_;
}
inline void Hero::set_combat(::google::protobuf::int32 value) {
  set_has_combat();
  combat_ = value;
}

// optional int32 coin = 49;
inline bool Hero::has_coin() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Hero::set_has_coin() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Hero::clear_has_coin() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void Hero::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 Hero::coin() const {
  return coin_;
}
inline void Hero::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional .protos.common.Item armor1 = 51;
inline bool Hero::has_armor1() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Hero::set_has_armor1() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Hero::clear_has_armor1() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void Hero::clear_armor1() {
  if (armor1_ != NULL) armor1_->::protos::common::Item::Clear();
  clear_has_armor1();
}
inline const ::protos::common::Item& Hero::armor1() const {
  return armor1_ != NULL ? *armor1_ : *default_instance_->armor1_;
}
inline ::protos::common::Item* Hero::mutable_armor1() {
  set_has_armor1();
  if (armor1_ == NULL) armor1_ = new ::protos::common::Item;
  return armor1_;
}
inline ::protos::common::Item* Hero::release_armor1() {
  clear_has_armor1();
  ::protos::common::Item* temp = armor1_;
  armor1_ = NULL;
  return temp;
}
inline void Hero::set_allocated_armor1(::protos::common::Item* armor1) {
  delete armor1_;
  armor1_ = armor1;
  if (armor1) {
    set_has_armor1();
  } else {
    clear_has_armor1();
  }
}

// optional .protos.common.Item armor2 = 52;
inline bool Hero::has_armor2() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Hero::set_has_armor2() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Hero::clear_has_armor2() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void Hero::clear_armor2() {
  if (armor2_ != NULL) armor2_->::protos::common::Item::Clear();
  clear_has_armor2();
}
inline const ::protos::common::Item& Hero::armor2() const {
  return armor2_ != NULL ? *armor2_ : *default_instance_->armor2_;
}
inline ::protos::common::Item* Hero::mutable_armor2() {
  set_has_armor2();
  if (armor2_ == NULL) armor2_ = new ::protos::common::Item;
  return armor2_;
}
inline ::protos::common::Item* Hero::release_armor2() {
  clear_has_armor2();
  ::protos::common::Item* temp = armor2_;
  armor2_ = NULL;
  return temp;
}
inline void Hero::set_allocated_armor2(::protos::common::Item* armor2) {
  delete armor2_;
  armor2_ = armor2;
  if (armor2) {
    set_has_armor2();
  } else {
    clear_has_armor2();
  }
}

// optional .protos.common.Item armor3 = 48;
inline bool Hero::has_armor3() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Hero::set_has_armor3() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Hero::clear_has_armor3() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void Hero::clear_armor3() {
  if (armor3_ != NULL) armor3_->::protos::common::Item::Clear();
  clear_has_armor3();
}
inline const ::protos::common::Item& Hero::armor3() const {
  return armor3_ != NULL ? *armor3_ : *default_instance_->armor3_;
}
inline ::protos::common::Item* Hero::mutable_armor3() {
  set_has_armor3();
  if (armor3_ == NULL) armor3_ = new ::protos::common::Item;
  return armor3_;
}
inline ::protos::common::Item* Hero::release_armor3() {
  clear_has_armor3();
  ::protos::common::Item* temp = armor3_;
  armor3_ = NULL;
  return temp;
}
inline void Hero::set_allocated_armor3(::protos::common::Item* armor3) {
  delete armor3_;
  armor3_ = armor3;
  if (armor3) {
    set_has_armor3();
  } else {
    clear_has_armor3();
  }
}

// optional .protos.common.Item armor4 = 50;
inline bool Hero::has_armor4() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Hero::set_has_armor4() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Hero::clear_has_armor4() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void Hero::clear_armor4() {
  if (armor4_ != NULL) armor4_->::protos::common::Item::Clear();
  clear_has_armor4();
}
inline const ::protos::common::Item& Hero::armor4() const {
  return armor4_ != NULL ? *armor4_ : *default_instance_->armor4_;
}
inline ::protos::common::Item* Hero::mutable_armor4() {
  set_has_armor4();
  if (armor4_ == NULL) armor4_ = new ::protos::common::Item;
  return armor4_;
}
inline ::protos::common::Item* Hero::release_armor4() {
  clear_has_armor4();
  ::protos::common::Item* temp = armor4_;
  armor4_ = NULL;
  return temp;
}
inline void Hero::set_allocated_armor4(::protos::common::Item* armor4) {
  delete armor4_;
  armor4_ = armor4;
  if (armor4) {
    set_has_armor4();
  } else {
    clear_has_armor4();
  }
}

// optional .protos.common.Item armor5 = 53;
inline bool Hero::has_armor5() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Hero::set_has_armor5() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Hero::clear_has_armor5() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void Hero::clear_armor5() {
  if (armor5_ != NULL) armor5_->::protos::common::Item::Clear();
  clear_has_armor5();
}
inline const ::protos::common::Item& Hero::armor5() const {
  return armor5_ != NULL ? *armor5_ : *default_instance_->armor5_;
}
inline ::protos::common::Item* Hero::mutable_armor5() {
  set_has_armor5();
  if (armor5_ == NULL) armor5_ = new ::protos::common::Item;
  return armor5_;
}
inline ::protos::common::Item* Hero::release_armor5() {
  clear_has_armor5();
  ::protos::common::Item* temp = armor5_;
  armor5_ = NULL;
  return temp;
}
inline void Hero::set_allocated_armor5(::protos::common::Item* armor5) {
  delete armor5_;
  armor5_ = armor5;
  if (armor5) {
    set_has_armor5();
  } else {
    clear_has_armor5();
  }
}

// optional int32 prate = 54;
inline bool Hero::has_prate() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Hero::set_has_prate() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Hero::clear_has_prate() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void Hero::clear_prate() {
  prate_ = 0;
  clear_has_prate();
}
inline ::google::protobuf::int32 Hero::prate() const {
  return prate_;
}
inline void Hero::set_prate(::google::protobuf::int32 value) {
  set_has_prate();
  prate_ = value;
}

// optional bool battle = 55;
inline bool Hero::has_battle() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Hero::set_has_battle() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Hero::clear_has_battle() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void Hero::clear_battle() {
  battle_ = false;
  clear_has_battle();
}
inline bool Hero::battle() const {
  return battle_;
}
inline void Hero::set_battle(bool value) {
  set_has_battle();
  battle_ = value;
}

// optional bool remove = 56;
inline bool Hero::has_remove() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Hero::set_has_remove() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Hero::clear_has_remove() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void Hero::clear_remove() {
  remove_ = false;
  clear_has_remove();
}
inline bool Hero::remove() const {
  return remove_;
}
inline void Hero::set_remove(bool value) {
  set_has_remove();
  remove_ = value;
}

// optional int32 color = 47;
inline bool Hero::has_color() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Hero::set_has_color() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Hero::clear_has_color() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Hero::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::google::protobuf::int32 Hero::color() const {
  return color_;
}
inline void Hero::set_color(::google::protobuf::int32 value) {
  set_has_color();
  color_ = value;
}

// optional bool evol = 57;
inline bool Hero::has_evol() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Hero::set_has_evol() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Hero::clear_has_evol() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Hero::clear_evol() {
  evol_ = false;
  clear_has_evol();
}
inline bool Hero::evol() const {
  return evol_;
}
inline void Hero::set_evol(bool value) {
  set_has_evol();
  evol_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2fhero_5fcommon_2eproto__INCLUDED
