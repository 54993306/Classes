// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/monster_common.proto

#ifndef PROTOBUF_common_2fmonster_5fcommon_2eproto__INCLUDED
#define PROTOBUF_common_2fmonster_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "skill_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protos {
namespace common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2fmonster_5fcommon_2eproto();
void protobuf_AssignDesc_common_2fmonster_5fcommon_2eproto();
void protobuf_ShutdownFile_common_2fmonster_5fcommon_2eproto();

class Monster;
class Pos;

// ===================================================================

class Monster : public ::google::protobuf::Message {
 public:
  Monster();
  virtual ~Monster();

  Monster(const Monster& from);

  inline Monster& operator=(const Monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Monster& default_instance();

  void Swap(Monster* other);

  // implements Message ----------------------------------------------

  Monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Monster& from);
  void MergeFrom(const Monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 monsterId = 2;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIdFieldNumber = 2;
  inline ::google::protobuf::int32 monsterid() const;
  inline void set_monsterid(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 atk = 4;
  inline bool has_atk() const;
  inline void clear_atk();
  static const int kAtkFieldNumber = 4;
  inline ::google::protobuf::int32 atk() const;
  inline void set_atk(::google::protobuf::int32 value);

  // optional int32 def = 5;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDefFieldNumber = 5;
  inline ::google::protobuf::int32 def() const;
  inline void set_def(::google::protobuf::int32 value);

  // optional float atkInterval = 6;
  inline bool has_atkinterval() const;
  inline void clear_atkinterval();
  static const int kAtkIntervalFieldNumber = 6;
  inline float atkinterval() const;
  inline void set_atkinterval(float value);

  // optional int32 hp = 7;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 7;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 crit = 8;
  inline bool has_crit() const;
  inline void clear_crit();
  static const int kCritFieldNumber = 8;
  inline ::google::protobuf::int32 crit() const;
  inline void set_crit(::google::protobuf::int32 value);

  // optional int32 hit = 9;
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHitFieldNumber = 9;
  inline ::google::protobuf::int32 hit() const;
  inline void set_hit(::google::protobuf::int32 value);

  // optional int32 dodge = 10;
  inline bool has_dodge() const;
  inline void clear_dodge();
  static const int kDodgeFieldNumber = 10;
  inline ::google::protobuf::int32 dodge() const;
  inline void set_dodge(::google::protobuf::int32 value);

  // optional int32 renew = 11;
  inline bool has_renew() const;
  inline void clear_renew();
  static const int kRenewFieldNumber = 11;
  inline ::google::protobuf::int32 renew() const;
  inline void set_renew(::google::protobuf::int32 value);

  // optional int32 minRound = 12;
  inline bool has_minround() const;
  inline void clear_minround();
  static const int kMinRoundFieldNumber = 12;
  inline ::google::protobuf::int32 minround() const;
  inline void set_minround(::google::protobuf::int32 value);

  // optional int32 maxRound = 13;
  inline bool has_maxround() const;
  inline void clear_maxround();
  static const int kMaxRoundFieldNumber = 13;
  inline ::google::protobuf::int32 maxround() const;
  inline void set_maxround(::google::protobuf::int32 value);

  // optional int32 addHurtRate = 14;
  inline bool has_addhurtrate() const;
  inline void clear_addhurtrate();
  static const int kAddHurtRateFieldNumber = 14;
  inline ::google::protobuf::int32 addhurtrate() const;
  inline void set_addhurtrate(::google::protobuf::int32 value);

  // optional int32 cutHurtRate = 15;
  inline bool has_cuthurtrate() const;
  inline void clear_cuthurtrate();
  static const int kCutHurtRateFieldNumber = 15;
  inline ::google::protobuf::int32 cuthurtrate() const;
  inline void set_cuthurtrate(::google::protobuf::int32 value);

  // optional int32 thumb = 16;
  inline bool has_thumb() const;
  inline void clear_thumb();
  static const int kThumbFieldNumber = 16;
  inline ::google::protobuf::int32 thumb() const;
  inline void set_thumb(::google::protobuf::int32 value);

  // repeated .protos.common.Pos posList = 17;
  inline int poslist_size() const;
  inline void clear_poslist();
  static const int kPosListFieldNumber = 17;
  inline const ::protos::common::Pos& poslist(int index) const;
  inline ::protos::common::Pos* mutable_poslist(int index);
  inline ::protos::common::Pos* add_poslist();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Pos >&
      poslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Pos >*
      mutable_poslist();

  // optional int32 zoom = 18;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 18;
  inline ::google::protobuf::int32 zoom() const;
  inline void set_zoom(::google::protobuf::int32 value);

  // optional int32 move1 = 19;
  inline bool has_move1() const;
  inline void clear_move1();
  static const int kMove1FieldNumber = 19;
  inline ::google::protobuf::int32 move1() const;
  inline void set_move1(::google::protobuf::int32 value);

  // optional int32 move2 = 20;
  inline bool has_move2() const;
  inline void clear_move2();
  static const int kMove2FieldNumber = 20;
  inline ::google::protobuf::int32 move2() const;
  inline void set_move2(::google::protobuf::int32 value);

  // optional int32 move3 = 21;
  inline bool has_move3() const;
  inline void clear_move3();
  static const int kMove3FieldNumber = 21;
  inline ::google::protobuf::int32 move3() const;
  inline void set_move3(::google::protobuf::int32 value);

  // optional int32 move4 = 22;
  inline bool has_move4() const;
  inline void clear_move4();
  static const int kMove4FieldNumber = 22;
  inline ::google::protobuf::int32 move4() const;
  inline void set_move4(::google::protobuf::int32 value);

  // optional int32 move5 = 23;
  inline bool has_move5() const;
  inline void clear_move5();
  static const int kMove5FieldNumber = 23;
  inline ::google::protobuf::int32 move5() const;
  inline void set_move5(::google::protobuf::int32 value);

  // optional .protos.common.Skill skill1 = 24;
  inline bool has_skill1() const;
  inline void clear_skill1();
  static const int kSkill1FieldNumber = 24;
  inline const ::protos::common::Skill& skill1() const;
  inline ::protos::common::Skill* mutable_skill1();
  inline ::protos::common::Skill* release_skill1();
  inline void set_allocated_skill1(::protos::common::Skill* skill1);

  // optional .protos.common.Skill skill2 = 25;
  inline bool has_skill2() const;
  inline void clear_skill2();
  static const int kSkill2FieldNumber = 25;
  inline const ::protos::common::Skill& skill2() const;
  inline ::protos::common::Skill* mutable_skill2();
  inline ::protos::common::Skill* release_skill2();
  inline void set_allocated_skill2(::protos::common::Skill* skill2);

  // optional .protos.common.Skill skill3 = 26;
  inline bool has_skill3() const;
  inline void clear_skill3();
  static const int kSkill3FieldNumber = 26;
  inline const ::protos::common::Skill& skill3() const;
  inline ::protos::common::Skill* mutable_skill3();
  inline ::protos::common::Skill* release_skill3();
  inline void set_allocated_skill3(::protos::common::Skill* skill3);

  // optional int32 foe = 28;
  inline bool has_foe() const;
  inline void clear_foe();
  static const int kFoeFieldNumber = 28;
  inline ::google::protobuf::int32 foe() const;
  inline void set_foe(::google::protobuf::int32 value);

  // optional int32 hasItem = 29;
  inline bool has_hasitem() const;
  inline void clear_hasitem();
  static const int kHasItemFieldNumber = 29;
  inline ::google::protobuf::int32 hasitem() const;
  inline void set_hasitem(::google::protobuf::int32 value);

  // optional int32 monsterType = 30;
  inline bool has_monstertype() const;
  inline void clear_monstertype();
  static const int kMonsterTypeFieldNumber = 30;
  inline ::google::protobuf::int32 monstertype() const;
  inline void set_monstertype(::google::protobuf::int32 value);

  // optional float moveSpeed = 31;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMoveSpeedFieldNumber = 31;
  inline float movespeed() const;
  inline void set_movespeed(float value);

  // optional int32 level = 32;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 32;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 quality = 33;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 33;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional bool isBoss = 34;
  inline bool has_isboss() const;
  inline void clear_isboss();
  static const int kIsBossFieldNumber = 34;
  inline bool isboss() const;
  inline void set_isboss(bool value);

  // optional int32 buff = 40;
  inline bool has_buff() const;
  inline void clear_buff();
  static const int kBuffFieldNumber = 40;
  inline ::google::protobuf::int32 buff() const;
  inline void set_buff(::google::protobuf::int32 value);

  // optional bool isCall = 35;
  inline bool has_iscall() const;
  inline void clear_iscall();
  static const int kIsCallFieldNumber = 35;
  inline bool iscall() const;
  inline void set_iscall(bool value);

  // optional int32 initCost = 36;
  inline bool has_initcost() const;
  inline void clear_initcost();
  static const int kInitCostFieldNumber = 36;
  inline ::google::protobuf::int32 initcost() const;
  inline void set_initcost(::google::protobuf::int32 value);

  // optional int32 addCost = 37;
  inline bool has_addcost() const;
  inline void clear_addcost();
  static const int kAddCostFieldNumber = 37;
  inline ::google::protobuf::int32 addcost() const;
  inline void set_addcost(::google::protobuf::int32 value);

  // optional int32 moveCost = 38;
  inline bool has_movecost() const;
  inline void clear_movecost();
  static const int kMoveCostFieldNumber = 38;
  inline ::google::protobuf::int32 movecost() const;
  inline void set_movecost(::google::protobuf::int32 value);

  // optional int32 maxCost = 39;
  inline bool has_maxcost() const;
  inline void clear_maxcost();
  static const int kMaxCostFieldNumber = 39;
  inline ::google::protobuf::int32 maxcost() const;
  inline void set_maxcost(::google::protobuf::int32 value);

  // optional int32 delay = 41;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 41;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);

  // optional int32 batch = 42;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 42;
  inline ::google::protobuf::int32 batch() const;
  inline void set_batch(::google::protobuf::int32 value);

  // optional int32 posX = 43;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosXFieldNumber = 43;
  inline ::google::protobuf::int32 posx() const;
  inline void set_posx(::google::protobuf::int32 value);

  // optional int32 posY = 44;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosYFieldNumber = 44;
  inline ::google::protobuf::int32 posy() const;
  inline void set_posy(::google::protobuf::int32 value);

  // optional int32 maxHp = 45;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxHpFieldNumber = 45;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.common.Monster)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_atk();
  inline void clear_has_atk();
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_atkinterval();
  inline void clear_has_atkinterval();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_crit();
  inline void clear_has_crit();
  inline void set_has_hit();
  inline void clear_has_hit();
  inline void set_has_dodge();
  inline void clear_has_dodge();
  inline void set_has_renew();
  inline void clear_has_renew();
  inline void set_has_minround();
  inline void clear_has_minround();
  inline void set_has_maxround();
  inline void clear_has_maxround();
  inline void set_has_addhurtrate();
  inline void clear_has_addhurtrate();
  inline void set_has_cuthurtrate();
  inline void clear_has_cuthurtrate();
  inline void set_has_thumb();
  inline void clear_has_thumb();
  inline void set_has_zoom();
  inline void clear_has_zoom();
  inline void set_has_move1();
  inline void clear_has_move1();
  inline void set_has_move2();
  inline void clear_has_move2();
  inline void set_has_move3();
  inline void clear_has_move3();
  inline void set_has_move4();
  inline void clear_has_move4();
  inline void set_has_move5();
  inline void clear_has_move5();
  inline void set_has_skill1();
  inline void clear_has_skill1();
  inline void set_has_skill2();
  inline void clear_has_skill2();
  inline void set_has_skill3();
  inline void clear_has_skill3();
  inline void set_has_foe();
  inline void clear_has_foe();
  inline void set_has_hasitem();
  inline void clear_has_hasitem();
  inline void set_has_monstertype();
  inline void clear_has_monstertype();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_isboss();
  inline void clear_has_isboss();
  inline void set_has_buff();
  inline void clear_has_buff();
  inline void set_has_iscall();
  inline void clear_has_iscall();
  inline void set_has_initcost();
  inline void clear_has_initcost();
  inline void set_has_addcost();
  inline void clear_has_addcost();
  inline void set_has_movecost();
  inline void clear_has_movecost();
  inline void set_has_maxcost();
  inline void clear_has_maxcost();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_batch();
  inline void clear_has_batch();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 monsterid_;
  ::std::string* name_;
  ::google::protobuf::int32 atk_;
  ::google::protobuf::int32 def_;
  float atkinterval_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 crit_;
  ::google::protobuf::int32 hit_;
  ::google::protobuf::int32 dodge_;
  ::google::protobuf::int32 renew_;
  ::google::protobuf::int32 minround_;
  ::google::protobuf::int32 maxround_;
  ::google::protobuf::int32 addhurtrate_;
  ::google::protobuf::int32 cuthurtrate_;
  ::google::protobuf::int32 thumb_;
  ::google::protobuf::int32 zoom_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Pos > poslist_;
  ::google::protobuf::int32 move1_;
  ::google::protobuf::int32 move2_;
  ::google::protobuf::int32 move3_;
  ::google::protobuf::int32 move4_;
  ::protos::common::Skill* skill1_;
  ::protos::common::Skill* skill2_;
  ::google::protobuf::int32 move5_;
  ::google::protobuf::int32 foe_;
  ::protos::common::Skill* skill3_;
  ::google::protobuf::int32 hasitem_;
  ::google::protobuf::int32 monstertype_;
  float movespeed_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 quality_;
  bool isboss_;
  bool iscall_;
  ::google::protobuf::int32 buff_;
  ::google::protobuf::int32 initcost_;
  ::google::protobuf::int32 addcost_;
  ::google::protobuf::int32 movecost_;
  ::google::protobuf::int32 maxcost_;
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int32 batch_;
  ::google::protobuf::int32 posx_;
  ::google::protobuf::int32 posy_;
  ::google::protobuf::int32 maxhp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(44 + 31) / 32];

  friend void  protobuf_AddDesc_common_2fmonster_5fcommon_2eproto();
  friend void protobuf_AssignDesc_common_2fmonster_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_common_2fmonster_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static Monster* default_instance_;
};
// -------------------------------------------------------------------

class Pos : public ::google::protobuf::Message {
 public:
  Pos();
  virtual ~Pos();

  Pos(const Pos& from);

  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pos& default_instance();

  void Swap(Pos* other);

  // implements Message ----------------------------------------------

  Pos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pos& from);
  void MergeFrom(const Pos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.common.Pos)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2fmonster_5fcommon_2eproto();
  friend void protobuf_AssignDesc_common_2fmonster_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_common_2fmonster_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static Pos* default_instance_;
};
// ===================================================================


// ===================================================================

// Monster

// optional int32 id = 1;
inline bool Monster::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Monster::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Monster::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Monster::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Monster::id() const {
  return id_;
}
inline void Monster::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 monsterId = 2;
inline bool Monster::has_monsterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Monster::set_has_monsterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Monster::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Monster::clear_monsterid() {
  monsterid_ = 0;
  clear_has_monsterid();
}
inline ::google::protobuf::int32 Monster::monsterid() const {
  return monsterid_;
}
inline void Monster::set_monsterid(::google::protobuf::int32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// optional string name = 3;
inline bool Monster::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Monster::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Monster::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Monster::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Monster::name() const {
  return *name_;
}
inline void Monster::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Monster::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Monster::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Monster::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Monster::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Monster::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 atk = 4;
inline bool Monster::has_atk() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Monster::set_has_atk() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Monster::clear_has_atk() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Monster::clear_atk() {
  atk_ = 0;
  clear_has_atk();
}
inline ::google::protobuf::int32 Monster::atk() const {
  return atk_;
}
inline void Monster::set_atk(::google::protobuf::int32 value) {
  set_has_atk();
  atk_ = value;
}

// optional int32 def = 5;
inline bool Monster::has_def() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Monster::set_has_def() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Monster::clear_has_def() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Monster::clear_def() {
  def_ = 0;
  clear_has_def();
}
inline ::google::protobuf::int32 Monster::def() const {
  return def_;
}
inline void Monster::set_def(::google::protobuf::int32 value) {
  set_has_def();
  def_ = value;
}

// optional float atkInterval = 6;
inline bool Monster::has_atkinterval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Monster::set_has_atkinterval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Monster::clear_has_atkinterval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Monster::clear_atkinterval() {
  atkinterval_ = 0;
  clear_has_atkinterval();
}
inline float Monster::atkinterval() const {
  return atkinterval_;
}
inline void Monster::set_atkinterval(float value) {
  set_has_atkinterval();
  atkinterval_ = value;
}

// optional int32 hp = 7;
inline bool Monster::has_hp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Monster::set_has_hp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Monster::clear_has_hp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Monster::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Monster::hp() const {
  return hp_;
}
inline void Monster::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 crit = 8;
inline bool Monster::has_crit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Monster::set_has_crit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Monster::clear_has_crit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Monster::clear_crit() {
  crit_ = 0;
  clear_has_crit();
}
inline ::google::protobuf::int32 Monster::crit() const {
  return crit_;
}
inline void Monster::set_crit(::google::protobuf::int32 value) {
  set_has_crit();
  crit_ = value;
}

// optional int32 hit = 9;
inline bool Monster::has_hit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Monster::set_has_hit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Monster::clear_has_hit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Monster::clear_hit() {
  hit_ = 0;
  clear_has_hit();
}
inline ::google::protobuf::int32 Monster::hit() const {
  return hit_;
}
inline void Monster::set_hit(::google::protobuf::int32 value) {
  set_has_hit();
  hit_ = value;
}

// optional int32 dodge = 10;
inline bool Monster::has_dodge() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Monster::set_has_dodge() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Monster::clear_has_dodge() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Monster::clear_dodge() {
  dodge_ = 0;
  clear_has_dodge();
}
inline ::google::protobuf::int32 Monster::dodge() const {
  return dodge_;
}
inline void Monster::set_dodge(::google::protobuf::int32 value) {
  set_has_dodge();
  dodge_ = value;
}

// optional int32 renew = 11;
inline bool Monster::has_renew() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Monster::set_has_renew() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Monster::clear_has_renew() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Monster::clear_renew() {
  renew_ = 0;
  clear_has_renew();
}
inline ::google::protobuf::int32 Monster::renew() const {
  return renew_;
}
inline void Monster::set_renew(::google::protobuf::int32 value) {
  set_has_renew();
  renew_ = value;
}

// optional int32 minRound = 12;
inline bool Monster::has_minround() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Monster::set_has_minround() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Monster::clear_has_minround() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Monster::clear_minround() {
  minround_ = 0;
  clear_has_minround();
}
inline ::google::protobuf::int32 Monster::minround() const {
  return minround_;
}
inline void Monster::set_minround(::google::protobuf::int32 value) {
  set_has_minround();
  minround_ = value;
}

// optional int32 maxRound = 13;
inline bool Monster::has_maxround() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Monster::set_has_maxround() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Monster::clear_has_maxround() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Monster::clear_maxround() {
  maxround_ = 0;
  clear_has_maxround();
}
inline ::google::protobuf::int32 Monster::maxround() const {
  return maxround_;
}
inline void Monster::set_maxround(::google::protobuf::int32 value) {
  set_has_maxround();
  maxround_ = value;
}

// optional int32 addHurtRate = 14;
inline bool Monster::has_addhurtrate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Monster::set_has_addhurtrate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Monster::clear_has_addhurtrate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Monster::clear_addhurtrate() {
  addhurtrate_ = 0;
  clear_has_addhurtrate();
}
inline ::google::protobuf::int32 Monster::addhurtrate() const {
  return addhurtrate_;
}
inline void Monster::set_addhurtrate(::google::protobuf::int32 value) {
  set_has_addhurtrate();
  addhurtrate_ = value;
}

// optional int32 cutHurtRate = 15;
inline bool Monster::has_cuthurtrate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Monster::set_has_cuthurtrate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Monster::clear_has_cuthurtrate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Monster::clear_cuthurtrate() {
  cuthurtrate_ = 0;
  clear_has_cuthurtrate();
}
inline ::google::protobuf::int32 Monster::cuthurtrate() const {
  return cuthurtrate_;
}
inline void Monster::set_cuthurtrate(::google::protobuf::int32 value) {
  set_has_cuthurtrate();
  cuthurtrate_ = value;
}

// optional int32 thumb = 16;
inline bool Monster::has_thumb() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Monster::set_has_thumb() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Monster::clear_has_thumb() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Monster::clear_thumb() {
  thumb_ = 0;
  clear_has_thumb();
}
inline ::google::protobuf::int32 Monster::thumb() const {
  return thumb_;
}
inline void Monster::set_thumb(::google::protobuf::int32 value) {
  set_has_thumb();
  thumb_ = value;
}

// repeated .protos.common.Pos posList = 17;
inline int Monster::poslist_size() const {
  return poslist_.size();
}
inline void Monster::clear_poslist() {
  poslist_.Clear();
}
inline const ::protos::common::Pos& Monster::poslist(int index) const {
  return poslist_.Get(index);
}
inline ::protos::common::Pos* Monster::mutable_poslist(int index) {
  return poslist_.Mutable(index);
}
inline ::protos::common::Pos* Monster::add_poslist() {
  return poslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Pos >&
Monster::poslist() const {
  return poslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Pos >*
Monster::mutable_poslist() {
  return &poslist_;
}

// optional int32 zoom = 18;
inline bool Monster::has_zoom() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Monster::set_has_zoom() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Monster::clear_has_zoom() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Monster::clear_zoom() {
  zoom_ = 0;
  clear_has_zoom();
}
inline ::google::protobuf::int32 Monster::zoom() const {
  return zoom_;
}
inline void Monster::set_zoom(::google::protobuf::int32 value) {
  set_has_zoom();
  zoom_ = value;
}

// optional int32 move1 = 19;
inline bool Monster::has_move1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Monster::set_has_move1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Monster::clear_has_move1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Monster::clear_move1() {
  move1_ = 0;
  clear_has_move1();
}
inline ::google::protobuf::int32 Monster::move1() const {
  return move1_;
}
inline void Monster::set_move1(::google::protobuf::int32 value) {
  set_has_move1();
  move1_ = value;
}

// optional int32 move2 = 20;
inline bool Monster::has_move2() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Monster::set_has_move2() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Monster::clear_has_move2() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Monster::clear_move2() {
  move2_ = 0;
  clear_has_move2();
}
inline ::google::protobuf::int32 Monster::move2() const {
  return move2_;
}
inline void Monster::set_move2(::google::protobuf::int32 value) {
  set_has_move2();
  move2_ = value;
}

// optional int32 move3 = 21;
inline bool Monster::has_move3() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Monster::set_has_move3() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Monster::clear_has_move3() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Monster::clear_move3() {
  move3_ = 0;
  clear_has_move3();
}
inline ::google::protobuf::int32 Monster::move3() const {
  return move3_;
}
inline void Monster::set_move3(::google::protobuf::int32 value) {
  set_has_move3();
  move3_ = value;
}

// optional int32 move4 = 22;
inline bool Monster::has_move4() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Monster::set_has_move4() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Monster::clear_has_move4() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Monster::clear_move4() {
  move4_ = 0;
  clear_has_move4();
}
inline ::google::protobuf::int32 Monster::move4() const {
  return move4_;
}
inline void Monster::set_move4(::google::protobuf::int32 value) {
  set_has_move4();
  move4_ = value;
}

// optional int32 move5 = 23;
inline bool Monster::has_move5() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Monster::set_has_move5() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Monster::clear_has_move5() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Monster::clear_move5() {
  move5_ = 0;
  clear_has_move5();
}
inline ::google::protobuf::int32 Monster::move5() const {
  return move5_;
}
inline void Monster::set_move5(::google::protobuf::int32 value) {
  set_has_move5();
  move5_ = value;
}

// optional .protos.common.Skill skill1 = 24;
inline bool Monster::has_skill1() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Monster::set_has_skill1() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Monster::clear_has_skill1() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Monster::clear_skill1() {
  if (skill1_ != NULL) skill1_->::protos::common::Skill::Clear();
  clear_has_skill1();
}
inline const ::protos::common::Skill& Monster::skill1() const {
  return skill1_ != NULL ? *skill1_ : *default_instance_->skill1_;
}
inline ::protos::common::Skill* Monster::mutable_skill1() {
  set_has_skill1();
  if (skill1_ == NULL) skill1_ = new ::protos::common::Skill;
  return skill1_;
}
inline ::protos::common::Skill* Monster::release_skill1() {
  clear_has_skill1();
  ::protos::common::Skill* temp = skill1_;
  skill1_ = NULL;
  return temp;
}
inline void Monster::set_allocated_skill1(::protos::common::Skill* skill1) {
  delete skill1_;
  skill1_ = skill1;
  if (skill1) {
    set_has_skill1();
  } else {
    clear_has_skill1();
  }
}

// optional .protos.common.Skill skill2 = 25;
inline bool Monster::has_skill2() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Monster::set_has_skill2() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Monster::clear_has_skill2() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Monster::clear_skill2() {
  if (skill2_ != NULL) skill2_->::protos::common::Skill::Clear();
  clear_has_skill2();
}
inline const ::protos::common::Skill& Monster::skill2() const {
  return skill2_ != NULL ? *skill2_ : *default_instance_->skill2_;
}
inline ::protos::common::Skill* Monster::mutable_skill2() {
  set_has_skill2();
  if (skill2_ == NULL) skill2_ = new ::protos::common::Skill;
  return skill2_;
}
inline ::protos::common::Skill* Monster::release_skill2() {
  clear_has_skill2();
  ::protos::common::Skill* temp = skill2_;
  skill2_ = NULL;
  return temp;
}
inline void Monster::set_allocated_skill2(::protos::common::Skill* skill2) {
  delete skill2_;
  skill2_ = skill2;
  if (skill2) {
    set_has_skill2();
  } else {
    clear_has_skill2();
  }
}

// optional .protos.common.Skill skill3 = 26;
inline bool Monster::has_skill3() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Monster::set_has_skill3() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Monster::clear_has_skill3() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Monster::clear_skill3() {
  if (skill3_ != NULL) skill3_->::protos::common::Skill::Clear();
  clear_has_skill3();
}
inline const ::protos::common::Skill& Monster::skill3() const {
  return skill3_ != NULL ? *skill3_ : *default_instance_->skill3_;
}
inline ::protos::common::Skill* Monster::mutable_skill3() {
  set_has_skill3();
  if (skill3_ == NULL) skill3_ = new ::protos::common::Skill;
  return skill3_;
}
inline ::protos::common::Skill* Monster::release_skill3() {
  clear_has_skill3();
  ::protos::common::Skill* temp = skill3_;
  skill3_ = NULL;
  return temp;
}
inline void Monster::set_allocated_skill3(::protos::common::Skill* skill3) {
  delete skill3_;
  skill3_ = skill3;
  if (skill3) {
    set_has_skill3();
  } else {
    clear_has_skill3();
  }
}

// optional int32 foe = 28;
inline bool Monster::has_foe() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Monster::set_has_foe() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Monster::clear_has_foe() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Monster::clear_foe() {
  foe_ = 0;
  clear_has_foe();
}
inline ::google::protobuf::int32 Monster::foe() const {
  return foe_;
}
inline void Monster::set_foe(::google::protobuf::int32 value) {
  set_has_foe();
  foe_ = value;
}

// optional int32 hasItem = 29;
inline bool Monster::has_hasitem() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Monster::set_has_hasitem() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Monster::clear_has_hasitem() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Monster::clear_hasitem() {
  hasitem_ = 0;
  clear_has_hasitem();
}
inline ::google::protobuf::int32 Monster::hasitem() const {
  return hasitem_;
}
inline void Monster::set_hasitem(::google::protobuf::int32 value) {
  set_has_hasitem();
  hasitem_ = value;
}

// optional int32 monsterType = 30;
inline bool Monster::has_monstertype() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Monster::set_has_monstertype() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Monster::clear_has_monstertype() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Monster::clear_monstertype() {
  monstertype_ = 0;
  clear_has_monstertype();
}
inline ::google::protobuf::int32 Monster::monstertype() const {
  return monstertype_;
}
inline void Monster::set_monstertype(::google::protobuf::int32 value) {
  set_has_monstertype();
  monstertype_ = value;
}

// optional float moveSpeed = 31;
inline bool Monster::has_movespeed() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Monster::set_has_movespeed() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Monster::clear_has_movespeed() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Monster::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline float Monster::movespeed() const {
  return movespeed_;
}
inline void Monster::set_movespeed(float value) {
  set_has_movespeed();
  movespeed_ = value;
}

// optional int32 level = 32;
inline bool Monster::has_level() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Monster::set_has_level() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Monster::clear_has_level() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Monster::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Monster::level() const {
  return level_;
}
inline void Monster::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 quality = 33;
inline bool Monster::has_quality() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Monster::set_has_quality() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Monster::clear_has_quality() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Monster::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 Monster::quality() const {
  return quality_;
}
inline void Monster::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional bool isBoss = 34;
inline bool Monster::has_isboss() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Monster::set_has_isboss() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Monster::clear_has_isboss() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Monster::clear_isboss() {
  isboss_ = false;
  clear_has_isboss();
}
inline bool Monster::isboss() const {
  return isboss_;
}
inline void Monster::set_isboss(bool value) {
  set_has_isboss();
  isboss_ = value;
}

// optional int32 buff = 40;
inline bool Monster::has_buff() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Monster::set_has_buff() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Monster::clear_has_buff() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Monster::clear_buff() {
  buff_ = 0;
  clear_has_buff();
}
inline ::google::protobuf::int32 Monster::buff() const {
  return buff_;
}
inline void Monster::set_buff(::google::protobuf::int32 value) {
  set_has_buff();
  buff_ = value;
}

// optional bool isCall = 35;
inline bool Monster::has_iscall() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Monster::set_has_iscall() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Monster::clear_has_iscall() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Monster::clear_iscall() {
  iscall_ = false;
  clear_has_iscall();
}
inline bool Monster::iscall() const {
  return iscall_;
}
inline void Monster::set_iscall(bool value) {
  set_has_iscall();
  iscall_ = value;
}

// optional int32 initCost = 36;
inline bool Monster::has_initcost() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Monster::set_has_initcost() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Monster::clear_has_initcost() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Monster::clear_initcost() {
  initcost_ = 0;
  clear_has_initcost();
}
inline ::google::protobuf::int32 Monster::initcost() const {
  return initcost_;
}
inline void Monster::set_initcost(::google::protobuf::int32 value) {
  set_has_initcost();
  initcost_ = value;
}

// optional int32 addCost = 37;
inline bool Monster::has_addcost() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Monster::set_has_addcost() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Monster::clear_has_addcost() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Monster::clear_addcost() {
  addcost_ = 0;
  clear_has_addcost();
}
inline ::google::protobuf::int32 Monster::addcost() const {
  return addcost_;
}
inline void Monster::set_addcost(::google::protobuf::int32 value) {
  set_has_addcost();
  addcost_ = value;
}

// optional int32 moveCost = 38;
inline bool Monster::has_movecost() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Monster::set_has_movecost() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Monster::clear_has_movecost() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Monster::clear_movecost() {
  movecost_ = 0;
  clear_has_movecost();
}
inline ::google::protobuf::int32 Monster::movecost() const {
  return movecost_;
}
inline void Monster::set_movecost(::google::protobuf::int32 value) {
  set_has_movecost();
  movecost_ = value;
}

// optional int32 maxCost = 39;
inline bool Monster::has_maxcost() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Monster::set_has_maxcost() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Monster::clear_has_maxcost() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Monster::clear_maxcost() {
  maxcost_ = 0;
  clear_has_maxcost();
}
inline ::google::protobuf::int32 Monster::maxcost() const {
  return maxcost_;
}
inline void Monster::set_maxcost(::google::protobuf::int32 value) {
  set_has_maxcost();
  maxcost_ = value;
}

// optional int32 delay = 41;
inline bool Monster::has_delay() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Monster::set_has_delay() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Monster::clear_has_delay() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Monster::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 Monster::delay() const {
  return delay_;
}
inline void Monster::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
}

// optional int32 batch = 42;
inline bool Monster::has_batch() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Monster::set_has_batch() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Monster::clear_has_batch() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Monster::clear_batch() {
  batch_ = 0;
  clear_has_batch();
}
inline ::google::protobuf::int32 Monster::batch() const {
  return batch_;
}
inline void Monster::set_batch(::google::protobuf::int32 value) {
  set_has_batch();
  batch_ = value;
}

// optional int32 posX = 43;
inline bool Monster::has_posx() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Monster::set_has_posx() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Monster::clear_has_posx() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Monster::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline ::google::protobuf::int32 Monster::posx() const {
  return posx_;
}
inline void Monster::set_posx(::google::protobuf::int32 value) {
  set_has_posx();
  posx_ = value;
}

// optional int32 posY = 44;
inline bool Monster::has_posy() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Monster::set_has_posy() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Monster::clear_has_posy() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Monster::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline ::google::protobuf::int32 Monster::posy() const {
  return posy_;
}
inline void Monster::set_posy(::google::protobuf::int32 value) {
  set_has_posy();
  posy_ = value;
}

// optional int32 maxHp = 45;
inline bool Monster::has_maxhp() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Monster::set_has_maxhp() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Monster::clear_has_maxhp() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Monster::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 Monster::maxhp() const {
  return maxhp_;
}
inline void Monster::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
}

// -------------------------------------------------------------------

// Pos

// required int32 x = 1;
inline bool Pos::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pos::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pos::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pos::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Pos::x() const {
  return x_;
}
inline void Pos::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Pos::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pos::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pos::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pos::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Pos::y() const {
  return y_;
}
inline void Pos::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2fmonster_5fcommon_2eproto__INCLUDED
