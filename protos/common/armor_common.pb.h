// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/armor_common.proto

#ifndef PROTOBUF_common_2farmor_5fcommon_2eproto__INCLUDED
#define PROTOBUF_common_2farmor_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protos {
namespace common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2farmor_5fcommon_2eproto();
void protobuf_AssignDesc_common_2farmor_5fcommon_2eproto();
void protobuf_ShutdownFile_common_2farmor_5fcommon_2eproto();

class Armor;

// ===================================================================

class Armor : public ::google::protobuf::Message {
 public:
  Armor();
  virtual ~Armor();

  Armor(const Armor& from);

  inline Armor& operator=(const Armor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Armor& default_instance();

  void Swap(Armor* other);

  // implements Message ----------------------------------------------

  Armor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Armor& from);
  void MergeFrom(const Armor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 armorType = 1;
  inline bool has_armortype() const;
  inline void clear_armortype();
  static const int kArmorTypeFieldNumber = 1;
  inline ::google::protobuf::int32 armortype() const;
  inline void set_armortype(::google::protobuf::int32 value);

  // optional int32 strenLv = 2;
  inline bool has_strenlv() const;
  inline void clear_strenlv();
  static const int kStrenLvFieldNumber = 2;
  inline ::google::protobuf::int32 strenlv() const;
  inline void set_strenlv(::google::protobuf::int32 value);

  // optional int32 hero = 3;
  inline bool has_hero() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 3;
  inline ::google::protobuf::int32 hero() const;
  inline void set_hero(::google::protobuf::int32 value);

  // optional int32 armor_skill = 4;
  inline bool has_armor_skill() const;
  inline void clear_armor_skill();
  static const int kArmorSkillFieldNumber = 4;
  inline ::google::protobuf::int32 armor_skill() const;
  inline void set_armor_skill(::google::protobuf::int32 value);

  // optional int32 baseHp = 5;
  inline bool has_basehp() const;
  inline void clear_basehp();
  static const int kBaseHpFieldNumber = 5;
  inline ::google::protobuf::int32 basehp() const;
  inline void set_basehp(::google::protobuf::int32 value);

  // optional int32 baseDef = 6;
  inline bool has_basedef() const;
  inline void clear_basedef();
  static const int kBaseDefFieldNumber = 6;
  inline ::google::protobuf::int32 basedef() const;
  inline void set_basedef(::google::protobuf::int32 value);

  // optional int32 baseAtk = 7;
  inline bool has_baseatk() const;
  inline void clear_baseatk();
  static const int kBaseAtkFieldNumber = 7;
  inline ::google::protobuf::int32 baseatk() const;
  inline void set_baseatk(::google::protobuf::int32 value);

  // optional int32 baseHit = 8;
  inline bool has_basehit() const;
  inline void clear_basehit();
  static const int kBaseHitFieldNumber = 8;
  inline ::google::protobuf::int32 basehit() const;
  inline void set_basehit(::google::protobuf::int32 value);

  // optional int32 baseDex = 9;
  inline bool has_basedex() const;
  inline void clear_basedex();
  static const int kBaseDexFieldNumber = 9;
  inline ::google::protobuf::int32 basedex() const;
  inline void set_basedex(::google::protobuf::int32 value);

  // optional int32 baseCrit = 10;
  inline bool has_basecrit() const;
  inline void clear_basecrit();
  static const int kBaseCritFieldNumber = 10;
  inline ::google::protobuf::int32 basecrit() const;
  inline void set_basecrit(::google::protobuf::int32 value);

  // optional int32 baseRenew = 11;
  inline bool has_baserenew() const;
  inline void clear_baserenew();
  static const int kBaseRenewFieldNumber = 11;
  inline ::google::protobuf::int32 baserenew() const;
  inline void set_baserenew(::google::protobuf::int32 value);

  // optional int32 baseDodge = 12;
  inline bool has_basedodge() const;
  inline void clear_basedodge();
  static const int kBaseDodgeFieldNumber = 12;
  inline ::google::protobuf::int32 basedodge() const;
  inline void set_basedodge(::google::protobuf::int32 value);

  // optional int32 addHp = 13;
  inline bool has_addhp() const;
  inline void clear_addhp();
  static const int kAddHpFieldNumber = 13;
  inline ::google::protobuf::int32 addhp() const;
  inline void set_addhp(::google::protobuf::int32 value);

  // optional int32 addDef = 14;
  inline bool has_adddef() const;
  inline void clear_adddef();
  static const int kAddDefFieldNumber = 14;
  inline ::google::protobuf::int32 adddef() const;
  inline void set_adddef(::google::protobuf::int32 value);

  // optional int32 addAtk = 15;
  inline bool has_addatk() const;
  inline void clear_addatk();
  static const int kAddAtkFieldNumber = 15;
  inline ::google::protobuf::int32 addatk() const;
  inline void set_addatk(::google::protobuf::int32 value);

  // optional int32 addHit = 16;
  inline bool has_addhit() const;
  inline void clear_addhit();
  static const int kAddHitFieldNumber = 16;
  inline ::google::protobuf::int32 addhit() const;
  inline void set_addhit(::google::protobuf::int32 value);

  // optional int32 addDex = 17;
  inline bool has_adddex() const;
  inline void clear_adddex();
  static const int kAddDexFieldNumber = 17;
  inline ::google::protobuf::int32 adddex() const;
  inline void set_adddex(::google::protobuf::int32 value);

  // optional int32 addCrit = 18;
  inline bool has_addcrit() const;
  inline void clear_addcrit();
  static const int kAddCritFieldNumber = 18;
  inline ::google::protobuf::int32 addcrit() const;
  inline void set_addcrit(::google::protobuf::int32 value);

  // optional int32 addRenew = 19;
  inline bool has_addrenew() const;
  inline void clear_addrenew();
  static const int kAddRenewFieldNumber = 19;
  inline ::google::protobuf::int32 addrenew() const;
  inline void set_addrenew(::google::protobuf::int32 value);

  // optional int32 addDodge = 20;
  inline bool has_adddodge() const;
  inline void clear_adddodge();
  static const int kAddDodgeFieldNumber = 20;
  inline ::google::protobuf::int32 adddodge() const;
  inline void set_adddodge(::google::protobuf::int32 value);

  // optional int32 nextAtk = 21;
  inline bool has_nextatk() const;
  inline void clear_nextatk();
  static const int kNextAtkFieldNumber = 21;
  inline ::google::protobuf::int32 nextatk() const;
  inline void set_nextatk(::google::protobuf::int32 value);

  // optional int32 nextHp = 22;
  inline bool has_nexthp() const;
  inline void clear_nexthp();
  static const int kNextHpFieldNumber = 22;
  inline ::google::protobuf::int32 nexthp() const;
  inline void set_nexthp(::google::protobuf::int32 value);

  // optional int32 nextDef = 23;
  inline bool has_nextdef() const;
  inline void clear_nextdef();
  static const int kNextDefFieldNumber = 23;
  inline ::google::protobuf::int32 nextdef() const;
  inline void set_nextdef(::google::protobuf::int32 value);

  // optional int32 nextHit = 24;
  inline bool has_nexthit() const;
  inline void clear_nexthit();
  static const int kNextHitFieldNumber = 24;
  inline ::google::protobuf::int32 nexthit() const;
  inline void set_nexthit(::google::protobuf::int32 value);

  // optional int32 nextDex = 25;
  inline bool has_nextdex() const;
  inline void clear_nextdex();
  static const int kNextDexFieldNumber = 25;
  inline ::google::protobuf::int32 nextdex() const;
  inline void set_nextdex(::google::protobuf::int32 value);

  // optional int32 nextCrit = 26;
  inline bool has_nextcrit() const;
  inline void clear_nextcrit();
  static const int kNextCritFieldNumber = 26;
  inline ::google::protobuf::int32 nextcrit() const;
  inline void set_nextcrit(::google::protobuf::int32 value);

  // optional int32 nextRenew = 27;
  inline bool has_nextrenew() const;
  inline void clear_nextrenew();
  static const int kNextRenewFieldNumber = 27;
  inline ::google::protobuf::int32 nextrenew() const;
  inline void set_nextrenew(::google::protobuf::int32 value);

  // optional int32 nextDodge = 28;
  inline bool has_nextdodge() const;
  inline void clear_nextdodge();
  static const int kNextDodgeFieldNumber = 28;
  inline ::google::protobuf::int32 nextdodge() const;
  inline void set_nextdodge(::google::protobuf::int32 value);

  // optional string atkRange = 29;
  inline bool has_atkrange() const;
  inline void clear_atkrange();
  static const int kAtkRangeFieldNumber = 29;
  inline const ::std::string& atkrange() const;
  inline void set_atkrange(const ::std::string& value);
  inline void set_atkrange(const char* value);
  inline void set_atkrange(const char* value, size_t size);
  inline ::std::string* mutable_atkrange();
  inline ::std::string* release_atkrange();
  inline void set_allocated_atkrange(::std::string* atkrange);

  // optional string hpRange = 30;
  inline bool has_hprange() const;
  inline void clear_hprange();
  static const int kHpRangeFieldNumber = 30;
  inline const ::std::string& hprange() const;
  inline void set_hprange(const ::std::string& value);
  inline void set_hprange(const char* value);
  inline void set_hprange(const char* value, size_t size);
  inline ::std::string* mutable_hprange();
  inline ::std::string* release_hprange();
  inline void set_allocated_hprange(::std::string* hprange);

  // optional string defRange = 31;
  inline bool has_defrange() const;
  inline void clear_defrange();
  static const int kDefRangeFieldNumber = 31;
  inline const ::std::string& defrange() const;
  inline void set_defrange(const ::std::string& value);
  inline void set_defrange(const char* value);
  inline void set_defrange(const char* value, size_t size);
  inline ::std::string* mutable_defrange();
  inline ::std::string* release_defrange();
  inline void set_allocated_defrange(::std::string* defrange);

  // optional string dexRange = 32;
  inline bool has_dexrange() const;
  inline void clear_dexrange();
  static const int kDexRangeFieldNumber = 32;
  inline const ::std::string& dexrange() const;
  inline void set_dexrange(const ::std::string& value);
  inline void set_dexrange(const char* value);
  inline void set_dexrange(const char* value, size_t size);
  inline ::std::string* mutable_dexrange();
  inline ::std::string* release_dexrange();
  inline void set_allocated_dexrange(::std::string* dexrange);

  // optional string hitRange = 33;
  inline bool has_hitrange() const;
  inline void clear_hitrange();
  static const int kHitRangeFieldNumber = 33;
  inline const ::std::string& hitrange() const;
  inline void set_hitrange(const ::std::string& value);
  inline void set_hitrange(const char* value);
  inline void set_hitrange(const char* value, size_t size);
  inline ::std::string* mutable_hitrange();
  inline ::std::string* release_hitrange();
  inline void set_allocated_hitrange(::std::string* hitrange);

  // optional string critRange = 34;
  inline bool has_critrange() const;
  inline void clear_critrange();
  static const int kCritRangeFieldNumber = 34;
  inline const ::std::string& critrange() const;
  inline void set_critrange(const ::std::string& value);
  inline void set_critrange(const char* value);
  inline void set_critrange(const char* value, size_t size);
  inline ::std::string* mutable_critrange();
  inline ::std::string* release_critrange();
  inline void set_allocated_critrange(::std::string* critrange);

  // optional string renewRange = 35;
  inline bool has_renewrange() const;
  inline void clear_renewrange();
  static const int kRenewRangeFieldNumber = 35;
  inline const ::std::string& renewrange() const;
  inline void set_renewrange(const ::std::string& value);
  inline void set_renewrange(const char* value);
  inline void set_renewrange(const char* value, size_t size);
  inline ::std::string* mutable_renewrange();
  inline ::std::string* release_renewrange();
  inline void set_allocated_renewrange(::std::string* renewrange);

  // optional string dodgeRange = 36;
  inline bool has_dodgerange() const;
  inline void clear_dodgerange();
  static const int kDodgeRangeFieldNumber = 36;
  inline const ::std::string& dodgerange() const;
  inline void set_dodgerange(const ::std::string& value);
  inline void set_dodgerange(const char* value);
  inline void set_dodgerange(const char* value, size_t size);
  inline ::std::string* mutable_dodgerange();
  inline ::std::string* release_dodgerange();
  inline void set_allocated_dodgerange(::std::string* dodgerange);

  // optional int32 combat = 37;
  inline bool has_combat() const;
  inline void clear_combat();
  static const int kCombatFieldNumber = 37;
  inline ::google::protobuf::int32 combat() const;
  inline void set_combat(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.common.Armor)
 private:
  inline void set_has_armortype();
  inline void clear_has_armortype();
  inline void set_has_strenlv();
  inline void clear_has_strenlv();
  inline void set_has_hero();
  inline void clear_has_hero();
  inline void set_has_armor_skill();
  inline void clear_has_armor_skill();
  inline void set_has_basehp();
  inline void clear_has_basehp();
  inline void set_has_basedef();
  inline void clear_has_basedef();
  inline void set_has_baseatk();
  inline void clear_has_baseatk();
  inline void set_has_basehit();
  inline void clear_has_basehit();
  inline void set_has_basedex();
  inline void clear_has_basedex();
  inline void set_has_basecrit();
  inline void clear_has_basecrit();
  inline void set_has_baserenew();
  inline void clear_has_baserenew();
  inline void set_has_basedodge();
  inline void clear_has_basedodge();
  inline void set_has_addhp();
  inline void clear_has_addhp();
  inline void set_has_adddef();
  inline void clear_has_adddef();
  inline void set_has_addatk();
  inline void clear_has_addatk();
  inline void set_has_addhit();
  inline void clear_has_addhit();
  inline void set_has_adddex();
  inline void clear_has_adddex();
  inline void set_has_addcrit();
  inline void clear_has_addcrit();
  inline void set_has_addrenew();
  inline void clear_has_addrenew();
  inline void set_has_adddodge();
  inline void clear_has_adddodge();
  inline void set_has_nextatk();
  inline void clear_has_nextatk();
  inline void set_has_nexthp();
  inline void clear_has_nexthp();
  inline void set_has_nextdef();
  inline void clear_has_nextdef();
  inline void set_has_nexthit();
  inline void clear_has_nexthit();
  inline void set_has_nextdex();
  inline void clear_has_nextdex();
  inline void set_has_nextcrit();
  inline void clear_has_nextcrit();
  inline void set_has_nextrenew();
  inline void clear_has_nextrenew();
  inline void set_has_nextdodge();
  inline void clear_has_nextdodge();
  inline void set_has_atkrange();
  inline void clear_has_atkrange();
  inline void set_has_hprange();
  inline void clear_has_hprange();
  inline void set_has_defrange();
  inline void clear_has_defrange();
  inline void set_has_dexrange();
  inline void clear_has_dexrange();
  inline void set_has_hitrange();
  inline void clear_has_hitrange();
  inline void set_has_critrange();
  inline void clear_has_critrange();
  inline void set_has_renewrange();
  inline void clear_has_renewrange();
  inline void set_has_dodgerange();
  inline void clear_has_dodgerange();
  inline void set_has_combat();
  inline void clear_has_combat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 armortype_;
  ::google::protobuf::int32 strenlv_;
  ::google::protobuf::int32 hero_;
  ::google::protobuf::int32 armor_skill_;
  ::google::protobuf::int32 basehp_;
  ::google::protobuf::int32 basedef_;
  ::google::protobuf::int32 baseatk_;
  ::google::protobuf::int32 basehit_;
  ::google::protobuf::int32 basedex_;
  ::google::protobuf::int32 basecrit_;
  ::google::protobuf::int32 baserenew_;
  ::google::protobuf::int32 basedodge_;
  ::google::protobuf::int32 addhp_;
  ::google::protobuf::int32 adddef_;
  ::google::protobuf::int32 addatk_;
  ::google::protobuf::int32 addhit_;
  ::google::protobuf::int32 adddex_;
  ::google::protobuf::int32 addcrit_;
  ::google::protobuf::int32 addrenew_;
  ::google::protobuf::int32 adddodge_;
  ::google::protobuf::int32 nextatk_;
  ::google::protobuf::int32 nexthp_;
  ::google::protobuf::int32 nextdef_;
  ::google::protobuf::int32 nexthit_;
  ::google::protobuf::int32 nextdex_;
  ::google::protobuf::int32 nextcrit_;
  ::google::protobuf::int32 nextrenew_;
  ::google::protobuf::int32 nextdodge_;
  ::std::string* atkrange_;
  ::std::string* hprange_;
  ::std::string* defrange_;
  ::std::string* dexrange_;
  ::std::string* hitrange_;
  ::std::string* critrange_;
  ::std::string* renewrange_;
  ::std::string* dodgerange_;
  ::google::protobuf::int32 combat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  friend void  protobuf_AddDesc_common_2farmor_5fcommon_2eproto();
  friend void protobuf_AssignDesc_common_2farmor_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_common_2farmor_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static Armor* default_instance_;
};
// ===================================================================


// ===================================================================

// Armor

// optional int32 armorType = 1;
inline bool Armor::has_armortype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Armor::set_has_armortype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Armor::clear_has_armortype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Armor::clear_armortype() {
  armortype_ = 0;
  clear_has_armortype();
}
inline ::google::protobuf::int32 Armor::armortype() const {
  return armortype_;
}
inline void Armor::set_armortype(::google::protobuf::int32 value) {
  set_has_armortype();
  armortype_ = value;
}

// optional int32 strenLv = 2;
inline bool Armor::has_strenlv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Armor::set_has_strenlv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Armor::clear_has_strenlv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Armor::clear_strenlv() {
  strenlv_ = 0;
  clear_has_strenlv();
}
inline ::google::protobuf::int32 Armor::strenlv() const {
  return strenlv_;
}
inline void Armor::set_strenlv(::google::protobuf::int32 value) {
  set_has_strenlv();
  strenlv_ = value;
}

// optional int32 hero = 3;
inline bool Armor::has_hero() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Armor::set_has_hero() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Armor::clear_has_hero() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Armor::clear_hero() {
  hero_ = 0;
  clear_has_hero();
}
inline ::google::protobuf::int32 Armor::hero() const {
  return hero_;
}
inline void Armor::set_hero(::google::protobuf::int32 value) {
  set_has_hero();
  hero_ = value;
}

// optional int32 armor_skill = 4;
inline bool Armor::has_armor_skill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Armor::set_has_armor_skill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Armor::clear_has_armor_skill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Armor::clear_armor_skill() {
  armor_skill_ = 0;
  clear_has_armor_skill();
}
inline ::google::protobuf::int32 Armor::armor_skill() const {
  return armor_skill_;
}
inline void Armor::set_armor_skill(::google::protobuf::int32 value) {
  set_has_armor_skill();
  armor_skill_ = value;
}

// optional int32 baseHp = 5;
inline bool Armor::has_basehp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Armor::set_has_basehp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Armor::clear_has_basehp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Armor::clear_basehp() {
  basehp_ = 0;
  clear_has_basehp();
}
inline ::google::protobuf::int32 Armor::basehp() const {
  return basehp_;
}
inline void Armor::set_basehp(::google::protobuf::int32 value) {
  set_has_basehp();
  basehp_ = value;
}

// optional int32 baseDef = 6;
inline bool Armor::has_basedef() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Armor::set_has_basedef() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Armor::clear_has_basedef() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Armor::clear_basedef() {
  basedef_ = 0;
  clear_has_basedef();
}
inline ::google::protobuf::int32 Armor::basedef() const {
  return basedef_;
}
inline void Armor::set_basedef(::google::protobuf::int32 value) {
  set_has_basedef();
  basedef_ = value;
}

// optional int32 baseAtk = 7;
inline bool Armor::has_baseatk() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Armor::set_has_baseatk() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Armor::clear_has_baseatk() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Armor::clear_baseatk() {
  baseatk_ = 0;
  clear_has_baseatk();
}
inline ::google::protobuf::int32 Armor::baseatk() const {
  return baseatk_;
}
inline void Armor::set_baseatk(::google::protobuf::int32 value) {
  set_has_baseatk();
  baseatk_ = value;
}

// optional int32 baseHit = 8;
inline bool Armor::has_basehit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Armor::set_has_basehit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Armor::clear_has_basehit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Armor::clear_basehit() {
  basehit_ = 0;
  clear_has_basehit();
}
inline ::google::protobuf::int32 Armor::basehit() const {
  return basehit_;
}
inline void Armor::set_basehit(::google::protobuf::int32 value) {
  set_has_basehit();
  basehit_ = value;
}

// optional int32 baseDex = 9;
inline bool Armor::has_basedex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Armor::set_has_basedex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Armor::clear_has_basedex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Armor::clear_basedex() {
  basedex_ = 0;
  clear_has_basedex();
}
inline ::google::protobuf::int32 Armor::basedex() const {
  return basedex_;
}
inline void Armor::set_basedex(::google::protobuf::int32 value) {
  set_has_basedex();
  basedex_ = value;
}

// optional int32 baseCrit = 10;
inline bool Armor::has_basecrit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Armor::set_has_basecrit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Armor::clear_has_basecrit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Armor::clear_basecrit() {
  basecrit_ = 0;
  clear_has_basecrit();
}
inline ::google::protobuf::int32 Armor::basecrit() const {
  return basecrit_;
}
inline void Armor::set_basecrit(::google::protobuf::int32 value) {
  set_has_basecrit();
  basecrit_ = value;
}

// optional int32 baseRenew = 11;
inline bool Armor::has_baserenew() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Armor::set_has_baserenew() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Armor::clear_has_baserenew() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Armor::clear_baserenew() {
  baserenew_ = 0;
  clear_has_baserenew();
}
inline ::google::protobuf::int32 Armor::baserenew() const {
  return baserenew_;
}
inline void Armor::set_baserenew(::google::protobuf::int32 value) {
  set_has_baserenew();
  baserenew_ = value;
}

// optional int32 baseDodge = 12;
inline bool Armor::has_basedodge() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Armor::set_has_basedodge() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Armor::clear_has_basedodge() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Armor::clear_basedodge() {
  basedodge_ = 0;
  clear_has_basedodge();
}
inline ::google::protobuf::int32 Armor::basedodge() const {
  return basedodge_;
}
inline void Armor::set_basedodge(::google::protobuf::int32 value) {
  set_has_basedodge();
  basedodge_ = value;
}

// optional int32 addHp = 13;
inline bool Armor::has_addhp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Armor::set_has_addhp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Armor::clear_has_addhp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Armor::clear_addhp() {
  addhp_ = 0;
  clear_has_addhp();
}
inline ::google::protobuf::int32 Armor::addhp() const {
  return addhp_;
}
inline void Armor::set_addhp(::google::protobuf::int32 value) {
  set_has_addhp();
  addhp_ = value;
}

// optional int32 addDef = 14;
inline bool Armor::has_adddef() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Armor::set_has_adddef() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Armor::clear_has_adddef() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Armor::clear_adddef() {
  adddef_ = 0;
  clear_has_adddef();
}
inline ::google::protobuf::int32 Armor::adddef() const {
  return adddef_;
}
inline void Armor::set_adddef(::google::protobuf::int32 value) {
  set_has_adddef();
  adddef_ = value;
}

// optional int32 addAtk = 15;
inline bool Armor::has_addatk() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Armor::set_has_addatk() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Armor::clear_has_addatk() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Armor::clear_addatk() {
  addatk_ = 0;
  clear_has_addatk();
}
inline ::google::protobuf::int32 Armor::addatk() const {
  return addatk_;
}
inline void Armor::set_addatk(::google::protobuf::int32 value) {
  set_has_addatk();
  addatk_ = value;
}

// optional int32 addHit = 16;
inline bool Armor::has_addhit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Armor::set_has_addhit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Armor::clear_has_addhit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Armor::clear_addhit() {
  addhit_ = 0;
  clear_has_addhit();
}
inline ::google::protobuf::int32 Armor::addhit() const {
  return addhit_;
}
inline void Armor::set_addhit(::google::protobuf::int32 value) {
  set_has_addhit();
  addhit_ = value;
}

// optional int32 addDex = 17;
inline bool Armor::has_adddex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Armor::set_has_adddex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Armor::clear_has_adddex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Armor::clear_adddex() {
  adddex_ = 0;
  clear_has_adddex();
}
inline ::google::protobuf::int32 Armor::adddex() const {
  return adddex_;
}
inline void Armor::set_adddex(::google::protobuf::int32 value) {
  set_has_adddex();
  adddex_ = value;
}

// optional int32 addCrit = 18;
inline bool Armor::has_addcrit() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Armor::set_has_addcrit() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Armor::clear_has_addcrit() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Armor::clear_addcrit() {
  addcrit_ = 0;
  clear_has_addcrit();
}
inline ::google::protobuf::int32 Armor::addcrit() const {
  return addcrit_;
}
inline void Armor::set_addcrit(::google::protobuf::int32 value) {
  set_has_addcrit();
  addcrit_ = value;
}

// optional int32 addRenew = 19;
inline bool Armor::has_addrenew() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Armor::set_has_addrenew() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Armor::clear_has_addrenew() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Armor::clear_addrenew() {
  addrenew_ = 0;
  clear_has_addrenew();
}
inline ::google::protobuf::int32 Armor::addrenew() const {
  return addrenew_;
}
inline void Armor::set_addrenew(::google::protobuf::int32 value) {
  set_has_addrenew();
  addrenew_ = value;
}

// optional int32 addDodge = 20;
inline bool Armor::has_adddodge() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Armor::set_has_adddodge() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Armor::clear_has_adddodge() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Armor::clear_adddodge() {
  adddodge_ = 0;
  clear_has_adddodge();
}
inline ::google::protobuf::int32 Armor::adddodge() const {
  return adddodge_;
}
inline void Armor::set_adddodge(::google::protobuf::int32 value) {
  set_has_adddodge();
  adddodge_ = value;
}

// optional int32 nextAtk = 21;
inline bool Armor::has_nextatk() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Armor::set_has_nextatk() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Armor::clear_has_nextatk() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Armor::clear_nextatk() {
  nextatk_ = 0;
  clear_has_nextatk();
}
inline ::google::protobuf::int32 Armor::nextatk() const {
  return nextatk_;
}
inline void Armor::set_nextatk(::google::protobuf::int32 value) {
  set_has_nextatk();
  nextatk_ = value;
}

// optional int32 nextHp = 22;
inline bool Armor::has_nexthp() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Armor::set_has_nexthp() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Armor::clear_has_nexthp() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Armor::clear_nexthp() {
  nexthp_ = 0;
  clear_has_nexthp();
}
inline ::google::protobuf::int32 Armor::nexthp() const {
  return nexthp_;
}
inline void Armor::set_nexthp(::google::protobuf::int32 value) {
  set_has_nexthp();
  nexthp_ = value;
}

// optional int32 nextDef = 23;
inline bool Armor::has_nextdef() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Armor::set_has_nextdef() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Armor::clear_has_nextdef() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Armor::clear_nextdef() {
  nextdef_ = 0;
  clear_has_nextdef();
}
inline ::google::protobuf::int32 Armor::nextdef() const {
  return nextdef_;
}
inline void Armor::set_nextdef(::google::protobuf::int32 value) {
  set_has_nextdef();
  nextdef_ = value;
}

// optional int32 nextHit = 24;
inline bool Armor::has_nexthit() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Armor::set_has_nexthit() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Armor::clear_has_nexthit() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Armor::clear_nexthit() {
  nexthit_ = 0;
  clear_has_nexthit();
}
inline ::google::protobuf::int32 Armor::nexthit() const {
  return nexthit_;
}
inline void Armor::set_nexthit(::google::protobuf::int32 value) {
  set_has_nexthit();
  nexthit_ = value;
}

// optional int32 nextDex = 25;
inline bool Armor::has_nextdex() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Armor::set_has_nextdex() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Armor::clear_has_nextdex() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Armor::clear_nextdex() {
  nextdex_ = 0;
  clear_has_nextdex();
}
inline ::google::protobuf::int32 Armor::nextdex() const {
  return nextdex_;
}
inline void Armor::set_nextdex(::google::protobuf::int32 value) {
  set_has_nextdex();
  nextdex_ = value;
}

// optional int32 nextCrit = 26;
inline bool Armor::has_nextcrit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Armor::set_has_nextcrit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Armor::clear_has_nextcrit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Armor::clear_nextcrit() {
  nextcrit_ = 0;
  clear_has_nextcrit();
}
inline ::google::protobuf::int32 Armor::nextcrit() const {
  return nextcrit_;
}
inline void Armor::set_nextcrit(::google::protobuf::int32 value) {
  set_has_nextcrit();
  nextcrit_ = value;
}

// optional int32 nextRenew = 27;
inline bool Armor::has_nextrenew() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Armor::set_has_nextrenew() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Armor::clear_has_nextrenew() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Armor::clear_nextrenew() {
  nextrenew_ = 0;
  clear_has_nextrenew();
}
inline ::google::protobuf::int32 Armor::nextrenew() const {
  return nextrenew_;
}
inline void Armor::set_nextrenew(::google::protobuf::int32 value) {
  set_has_nextrenew();
  nextrenew_ = value;
}

// optional int32 nextDodge = 28;
inline bool Armor::has_nextdodge() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Armor::set_has_nextdodge() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Armor::clear_has_nextdodge() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Armor::clear_nextdodge() {
  nextdodge_ = 0;
  clear_has_nextdodge();
}
inline ::google::protobuf::int32 Armor::nextdodge() const {
  return nextdodge_;
}
inline void Armor::set_nextdodge(::google::protobuf::int32 value) {
  set_has_nextdodge();
  nextdodge_ = value;
}

// optional string atkRange = 29;
inline bool Armor::has_atkrange() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Armor::set_has_atkrange() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Armor::clear_has_atkrange() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Armor::clear_atkrange() {
  if (atkrange_ != &::google::protobuf::internal::kEmptyString) {
    atkrange_->clear();
  }
  clear_has_atkrange();
}
inline const ::std::string& Armor::atkrange() const {
  return *atkrange_;
}
inline void Armor::set_atkrange(const ::std::string& value) {
  set_has_atkrange();
  if (atkrange_ == &::google::protobuf::internal::kEmptyString) {
    atkrange_ = new ::std::string;
  }
  atkrange_->assign(value);
}
inline void Armor::set_atkrange(const char* value) {
  set_has_atkrange();
  if (atkrange_ == &::google::protobuf::internal::kEmptyString) {
    atkrange_ = new ::std::string;
  }
  atkrange_->assign(value);
}
inline void Armor::set_atkrange(const char* value, size_t size) {
  set_has_atkrange();
  if (atkrange_ == &::google::protobuf::internal::kEmptyString) {
    atkrange_ = new ::std::string;
  }
  atkrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_atkrange() {
  set_has_atkrange();
  if (atkrange_ == &::google::protobuf::internal::kEmptyString) {
    atkrange_ = new ::std::string;
  }
  return atkrange_;
}
inline ::std::string* Armor::release_atkrange() {
  clear_has_atkrange();
  if (atkrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = atkrange_;
    atkrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_atkrange(::std::string* atkrange) {
  if (atkrange_ != &::google::protobuf::internal::kEmptyString) {
    delete atkrange_;
  }
  if (atkrange) {
    set_has_atkrange();
    atkrange_ = atkrange;
  } else {
    clear_has_atkrange();
    atkrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hpRange = 30;
inline bool Armor::has_hprange() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Armor::set_has_hprange() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Armor::clear_has_hprange() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Armor::clear_hprange() {
  if (hprange_ != &::google::protobuf::internal::kEmptyString) {
    hprange_->clear();
  }
  clear_has_hprange();
}
inline const ::std::string& Armor::hprange() const {
  return *hprange_;
}
inline void Armor::set_hprange(const ::std::string& value) {
  set_has_hprange();
  if (hprange_ == &::google::protobuf::internal::kEmptyString) {
    hprange_ = new ::std::string;
  }
  hprange_->assign(value);
}
inline void Armor::set_hprange(const char* value) {
  set_has_hprange();
  if (hprange_ == &::google::protobuf::internal::kEmptyString) {
    hprange_ = new ::std::string;
  }
  hprange_->assign(value);
}
inline void Armor::set_hprange(const char* value, size_t size) {
  set_has_hprange();
  if (hprange_ == &::google::protobuf::internal::kEmptyString) {
    hprange_ = new ::std::string;
  }
  hprange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_hprange() {
  set_has_hprange();
  if (hprange_ == &::google::protobuf::internal::kEmptyString) {
    hprange_ = new ::std::string;
  }
  return hprange_;
}
inline ::std::string* Armor::release_hprange() {
  clear_has_hprange();
  if (hprange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hprange_;
    hprange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_hprange(::std::string* hprange) {
  if (hprange_ != &::google::protobuf::internal::kEmptyString) {
    delete hprange_;
  }
  if (hprange) {
    set_has_hprange();
    hprange_ = hprange;
  } else {
    clear_has_hprange();
    hprange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string defRange = 31;
inline bool Armor::has_defrange() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Armor::set_has_defrange() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Armor::clear_has_defrange() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Armor::clear_defrange() {
  if (defrange_ != &::google::protobuf::internal::kEmptyString) {
    defrange_->clear();
  }
  clear_has_defrange();
}
inline const ::std::string& Armor::defrange() const {
  return *defrange_;
}
inline void Armor::set_defrange(const ::std::string& value) {
  set_has_defrange();
  if (defrange_ == &::google::protobuf::internal::kEmptyString) {
    defrange_ = new ::std::string;
  }
  defrange_->assign(value);
}
inline void Armor::set_defrange(const char* value) {
  set_has_defrange();
  if (defrange_ == &::google::protobuf::internal::kEmptyString) {
    defrange_ = new ::std::string;
  }
  defrange_->assign(value);
}
inline void Armor::set_defrange(const char* value, size_t size) {
  set_has_defrange();
  if (defrange_ == &::google::protobuf::internal::kEmptyString) {
    defrange_ = new ::std::string;
  }
  defrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_defrange() {
  set_has_defrange();
  if (defrange_ == &::google::protobuf::internal::kEmptyString) {
    defrange_ = new ::std::string;
  }
  return defrange_;
}
inline ::std::string* Armor::release_defrange() {
  clear_has_defrange();
  if (defrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defrange_;
    defrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_defrange(::std::string* defrange) {
  if (defrange_ != &::google::protobuf::internal::kEmptyString) {
    delete defrange_;
  }
  if (defrange) {
    set_has_defrange();
    defrange_ = defrange;
  } else {
    clear_has_defrange();
    defrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dexRange = 32;
inline bool Armor::has_dexrange() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Armor::set_has_dexrange() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Armor::clear_has_dexrange() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Armor::clear_dexrange() {
  if (dexrange_ != &::google::protobuf::internal::kEmptyString) {
    dexrange_->clear();
  }
  clear_has_dexrange();
}
inline const ::std::string& Armor::dexrange() const {
  return *dexrange_;
}
inline void Armor::set_dexrange(const ::std::string& value) {
  set_has_dexrange();
  if (dexrange_ == &::google::protobuf::internal::kEmptyString) {
    dexrange_ = new ::std::string;
  }
  dexrange_->assign(value);
}
inline void Armor::set_dexrange(const char* value) {
  set_has_dexrange();
  if (dexrange_ == &::google::protobuf::internal::kEmptyString) {
    dexrange_ = new ::std::string;
  }
  dexrange_->assign(value);
}
inline void Armor::set_dexrange(const char* value, size_t size) {
  set_has_dexrange();
  if (dexrange_ == &::google::protobuf::internal::kEmptyString) {
    dexrange_ = new ::std::string;
  }
  dexrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_dexrange() {
  set_has_dexrange();
  if (dexrange_ == &::google::protobuf::internal::kEmptyString) {
    dexrange_ = new ::std::string;
  }
  return dexrange_;
}
inline ::std::string* Armor::release_dexrange() {
  clear_has_dexrange();
  if (dexrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dexrange_;
    dexrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_dexrange(::std::string* dexrange) {
  if (dexrange_ != &::google::protobuf::internal::kEmptyString) {
    delete dexrange_;
  }
  if (dexrange) {
    set_has_dexrange();
    dexrange_ = dexrange;
  } else {
    clear_has_dexrange();
    dexrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hitRange = 33;
inline bool Armor::has_hitrange() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Armor::set_has_hitrange() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Armor::clear_has_hitrange() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Armor::clear_hitrange() {
  if (hitrange_ != &::google::protobuf::internal::kEmptyString) {
    hitrange_->clear();
  }
  clear_has_hitrange();
}
inline const ::std::string& Armor::hitrange() const {
  return *hitrange_;
}
inline void Armor::set_hitrange(const ::std::string& value) {
  set_has_hitrange();
  if (hitrange_ == &::google::protobuf::internal::kEmptyString) {
    hitrange_ = new ::std::string;
  }
  hitrange_->assign(value);
}
inline void Armor::set_hitrange(const char* value) {
  set_has_hitrange();
  if (hitrange_ == &::google::protobuf::internal::kEmptyString) {
    hitrange_ = new ::std::string;
  }
  hitrange_->assign(value);
}
inline void Armor::set_hitrange(const char* value, size_t size) {
  set_has_hitrange();
  if (hitrange_ == &::google::protobuf::internal::kEmptyString) {
    hitrange_ = new ::std::string;
  }
  hitrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_hitrange() {
  set_has_hitrange();
  if (hitrange_ == &::google::protobuf::internal::kEmptyString) {
    hitrange_ = new ::std::string;
  }
  return hitrange_;
}
inline ::std::string* Armor::release_hitrange() {
  clear_has_hitrange();
  if (hitrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hitrange_;
    hitrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_hitrange(::std::string* hitrange) {
  if (hitrange_ != &::google::protobuf::internal::kEmptyString) {
    delete hitrange_;
  }
  if (hitrange) {
    set_has_hitrange();
    hitrange_ = hitrange;
  } else {
    clear_has_hitrange();
    hitrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string critRange = 34;
inline bool Armor::has_critrange() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Armor::set_has_critrange() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Armor::clear_has_critrange() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Armor::clear_critrange() {
  if (critrange_ != &::google::protobuf::internal::kEmptyString) {
    critrange_->clear();
  }
  clear_has_critrange();
}
inline const ::std::string& Armor::critrange() const {
  return *critrange_;
}
inline void Armor::set_critrange(const ::std::string& value) {
  set_has_critrange();
  if (critrange_ == &::google::protobuf::internal::kEmptyString) {
    critrange_ = new ::std::string;
  }
  critrange_->assign(value);
}
inline void Armor::set_critrange(const char* value) {
  set_has_critrange();
  if (critrange_ == &::google::protobuf::internal::kEmptyString) {
    critrange_ = new ::std::string;
  }
  critrange_->assign(value);
}
inline void Armor::set_critrange(const char* value, size_t size) {
  set_has_critrange();
  if (critrange_ == &::google::protobuf::internal::kEmptyString) {
    critrange_ = new ::std::string;
  }
  critrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_critrange() {
  set_has_critrange();
  if (critrange_ == &::google::protobuf::internal::kEmptyString) {
    critrange_ = new ::std::string;
  }
  return critrange_;
}
inline ::std::string* Armor::release_critrange() {
  clear_has_critrange();
  if (critrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = critrange_;
    critrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_critrange(::std::string* critrange) {
  if (critrange_ != &::google::protobuf::internal::kEmptyString) {
    delete critrange_;
  }
  if (critrange) {
    set_has_critrange();
    critrange_ = critrange;
  } else {
    clear_has_critrange();
    critrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string renewRange = 35;
inline bool Armor::has_renewrange() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Armor::set_has_renewrange() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Armor::clear_has_renewrange() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Armor::clear_renewrange() {
  if (renewrange_ != &::google::protobuf::internal::kEmptyString) {
    renewrange_->clear();
  }
  clear_has_renewrange();
}
inline const ::std::string& Armor::renewrange() const {
  return *renewrange_;
}
inline void Armor::set_renewrange(const ::std::string& value) {
  set_has_renewrange();
  if (renewrange_ == &::google::protobuf::internal::kEmptyString) {
    renewrange_ = new ::std::string;
  }
  renewrange_->assign(value);
}
inline void Armor::set_renewrange(const char* value) {
  set_has_renewrange();
  if (renewrange_ == &::google::protobuf::internal::kEmptyString) {
    renewrange_ = new ::std::string;
  }
  renewrange_->assign(value);
}
inline void Armor::set_renewrange(const char* value, size_t size) {
  set_has_renewrange();
  if (renewrange_ == &::google::protobuf::internal::kEmptyString) {
    renewrange_ = new ::std::string;
  }
  renewrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_renewrange() {
  set_has_renewrange();
  if (renewrange_ == &::google::protobuf::internal::kEmptyString) {
    renewrange_ = new ::std::string;
  }
  return renewrange_;
}
inline ::std::string* Armor::release_renewrange() {
  clear_has_renewrange();
  if (renewrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewrange_;
    renewrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_renewrange(::std::string* renewrange) {
  if (renewrange_ != &::google::protobuf::internal::kEmptyString) {
    delete renewrange_;
  }
  if (renewrange) {
    set_has_renewrange();
    renewrange_ = renewrange;
  } else {
    clear_has_renewrange();
    renewrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dodgeRange = 36;
inline bool Armor::has_dodgerange() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Armor::set_has_dodgerange() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Armor::clear_has_dodgerange() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Armor::clear_dodgerange() {
  if (dodgerange_ != &::google::protobuf::internal::kEmptyString) {
    dodgerange_->clear();
  }
  clear_has_dodgerange();
}
inline const ::std::string& Armor::dodgerange() const {
  return *dodgerange_;
}
inline void Armor::set_dodgerange(const ::std::string& value) {
  set_has_dodgerange();
  if (dodgerange_ == &::google::protobuf::internal::kEmptyString) {
    dodgerange_ = new ::std::string;
  }
  dodgerange_->assign(value);
}
inline void Armor::set_dodgerange(const char* value) {
  set_has_dodgerange();
  if (dodgerange_ == &::google::protobuf::internal::kEmptyString) {
    dodgerange_ = new ::std::string;
  }
  dodgerange_->assign(value);
}
inline void Armor::set_dodgerange(const char* value, size_t size) {
  set_has_dodgerange();
  if (dodgerange_ == &::google::protobuf::internal::kEmptyString) {
    dodgerange_ = new ::std::string;
  }
  dodgerange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Armor::mutable_dodgerange() {
  set_has_dodgerange();
  if (dodgerange_ == &::google::protobuf::internal::kEmptyString) {
    dodgerange_ = new ::std::string;
  }
  return dodgerange_;
}
inline ::std::string* Armor::release_dodgerange() {
  clear_has_dodgerange();
  if (dodgerange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dodgerange_;
    dodgerange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Armor::set_allocated_dodgerange(::std::string* dodgerange) {
  if (dodgerange_ != &::google::protobuf::internal::kEmptyString) {
    delete dodgerange_;
  }
  if (dodgerange) {
    set_has_dodgerange();
    dodgerange_ = dodgerange;
  } else {
    clear_has_dodgerange();
    dodgerange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 combat = 37;
inline bool Armor::has_combat() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Armor::set_has_combat() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Armor::clear_has_combat() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Armor::clear_combat() {
  combat_ = 0;
  clear_has_combat();
}
inline ::google::protobuf::int32 Armor::combat() const {
  return combat_;
}
inline void Armor::set_combat(::google::protobuf::int32 value) {
  set_has_combat();
  combat_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2farmor_5fcommon_2eproto__INCLUDED
