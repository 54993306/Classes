// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pvp_protocol.proto

#ifndef PROTOBUF_pvp_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_pvp_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/prize_common.pb.h"
#include "common/hero_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

class PvpTeamData;
class PvpDataReq;
class PvpDataRes;
class PvpPrizeList;
class OppTeamReq;
class OppTeamRes;
class Member;
class Opponent;
class PvpPrize;

// ===================================================================

class PvpTeamData : public ::google::protobuf::Message {
 public:
  PvpTeamData();
  virtual ~PvpTeamData();

  PvpTeamData(const PvpTeamData& from);

  inline PvpTeamData& operator=(const PvpTeamData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpTeamData& default_instance();

  void Swap(PvpTeamData* other);

  // implements Message ----------------------------------------------

  PvpTeamData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpTeamData& from);
  void MergeFrom(const PvpTeamData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .protos.Member team = 2;
  inline int team_size() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 2;
  inline const ::protos::Member& team(int index) const;
  inline ::protos::Member* mutable_team(int index);
  inline ::protos::Member* add_team();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::Member >&
      team() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::Member >*
      mutable_team();

  // @@protoc_insertion_point(class_scope:protos.PvpTeamData)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protos::Member > team_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpTeamData* default_instance_;
};
// -------------------------------------------------------------------

class PvpDataReq : public ::google::protobuf::Message {
 public:
  PvpDataReq();
  virtual ~PvpDataReq();

  PvpDataReq(const PvpDataReq& from);

  inline PvpDataReq& operator=(const PvpDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpDataReq& default_instance();

  void Swap(PvpDataReq* other);

  // implements Message ----------------------------------------------

  PvpDataReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpDataReq& from);
  void MergeFrom(const PvpDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool refresh = 1;
  inline bool has_refresh() const;
  inline void clear_refresh();
  static const int kRefreshFieldNumber = 1;
  inline bool refresh() const;
  inline void set_refresh(bool value);

  // @@protoc_insertion_point(class_scope:protos.PvpDataReq)
 private:
  inline void set_has_refresh();
  inline void clear_has_refresh();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool refresh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpDataReq* default_instance_;
};
// -------------------------------------------------------------------

class PvpDataRes : public ::google::protobuf::Message {
 public:
  PvpDataRes();
  virtual ~PvpDataRes();

  PvpDataRes(const PvpDataRes& from);

  inline PvpDataRes& operator=(const PvpDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpDataRes& default_instance();

  void Swap(PvpDataRes* other);

  // implements Message ----------------------------------------------

  PvpDataRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpDataRes& from);
  void MergeFrom(const PvpDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 max_time = 1;
  inline bool has_max_time() const;
  inline void clear_max_time();
  static const int kMaxTimeFieldNumber = 1;
  inline ::google::protobuf::int32 max_time() const;
  inline void set_max_time(::google::protobuf::int32 value);

  // optional int32 now_time = 2;
  inline bool has_now_time() const;
  inline void clear_now_time();
  static const int kNowTimeFieldNumber = 2;
  inline ::google::protobuf::int32 now_time() const;
  inline void set_now_time(::google::protobuf::int32 value);

  // repeated .protos.Opponent opponents = 3;
  inline int opponents_size() const;
  inline void clear_opponents();
  static const int kOpponentsFieldNumber = 3;
  inline const ::protos::Opponent& opponents(int index) const;
  inline ::protos::Opponent* mutable_opponents(int index);
  inline ::protos::Opponent* add_opponents();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::Opponent >&
      opponents() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::Opponent >*
      mutable_opponents();

  // optional .protos.PvpPrize prize = 4;
  inline bool has_prize() const;
  inline void clear_prize();
  static const int kPrizeFieldNumber = 4;
  inline const ::protos::PvpPrize& prize() const;
  inline ::protos::PvpPrize* mutable_prize();
  inline ::protos::PvpPrize* release_prize();
  inline void set_allocated_prize(::protos::PvpPrize* prize);

  // optional int32 cd_time = 5;
  inline bool has_cd_time() const;
  inline void clear_cd_time();
  static const int kCdTimeFieldNumber = 5;
  inline ::google::protobuf::int32 cd_time() const;
  inline void set_cd_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.PvpDataRes)
 private:
  inline void set_has_max_time();
  inline void clear_has_max_time();
  inline void set_has_now_time();
  inline void clear_has_now_time();
  inline void set_has_prize();
  inline void clear_has_prize();
  inline void set_has_cd_time();
  inline void clear_has_cd_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 max_time_;
  ::google::protobuf::int32 now_time_;
  ::google::protobuf::RepeatedPtrField< ::protos::Opponent > opponents_;
  ::protos::PvpPrize* prize_;
  ::google::protobuf::int32 cd_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpDataRes* default_instance_;
};
// -------------------------------------------------------------------

class PvpPrizeList : public ::google::protobuf::Message {
 public:
  PvpPrizeList();
  virtual ~PvpPrizeList();

  PvpPrizeList(const PvpPrizeList& from);

  inline PvpPrizeList& operator=(const PvpPrizeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpPrizeList& default_instance();

  void Swap(PvpPrizeList* other);

  // implements Message ----------------------------------------------

  PvpPrizeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpPrizeList& from);
  void MergeFrom(const PvpPrizeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protos.PvpPrize prize_list = 1;
  inline int prize_list_size() const;
  inline void clear_prize_list();
  static const int kPrizeListFieldNumber = 1;
  inline const ::protos::PvpPrize& prize_list(int index) const;
  inline ::protos::PvpPrize* mutable_prize_list(int index);
  inline ::protos::PvpPrize* add_prize_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >&
      prize_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >*
      mutable_prize_list();

  // @@protoc_insertion_point(class_scope:protos.PvpPrizeList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize > prize_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpPrizeList* default_instance_;
};
// -------------------------------------------------------------------

class OppTeamReq : public ::google::protobuf::Message {
 public:
  OppTeamReq();
  virtual ~OppTeamReq();

  OppTeamReq(const OppTeamReq& from);

  inline OppTeamReq& operator=(const OppTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OppTeamReq& default_instance();

  void Swap(OppTeamReq* other);

  // implements Message ----------------------------------------------

  OppTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OppTeamReq& from);
  void MergeFrom(const OppTeamReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 role_id() const;
  inline void set_role_id(::google::protobuf::int32 value);

  // required bool is_robot = 2;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 2;
  inline bool is_robot() const;
  inline void set_is_robot(bool value);

  // @@protoc_insertion_point(class_scope:protos.OppTeamReq)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 role_id_;
  bool is_robot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static OppTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class OppTeamRes : public ::google::protobuf::Message {
 public:
  OppTeamRes();
  virtual ~OppTeamRes();

  OppTeamRes(const OppTeamRes& from);

  inline OppTeamRes& operator=(const OppTeamRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OppTeamRes& default_instance();

  void Swap(OppTeamRes* other);

  // implements Message ----------------------------------------------

  OppTeamRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OppTeamRes& from);
  void MergeFrom(const OppTeamRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 captin_skill_id = 2;
  inline bool has_captin_skill_id() const;
  inline void clear_captin_skill_id();
  static const int kCaptinSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 captin_skill_id() const;
  inline void set_captin_skill_id(::google::protobuf::int32 value);

  // repeated .protos.common.Hero hero_list = 3;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 3;
  inline const ::protos::common::Hero& hero_list(int index) const;
  inline ::protos::common::Hero* mutable_hero_list(int index);
  inline ::protos::common::Hero* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:protos.OppTeamRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_captin_skill_id();
  inline void clear_has_captin_skill_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 captin_skill_id_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Hero > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static OppTeamRes* default_instance_;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::Message {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Member& default_instance();

  void Swap(Member* other);

  // implements Message ----------------------------------------------

  Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 hero_id = 1;
  inline bool has_hero_id() const;
  inline void clear_hero_id();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::int32 hero_id() const;
  inline void set_hero_id(::google::protobuf::int32 value);

  // required bool captin = 2;
  inline bool has_captin() const;
  inline void clear_captin();
  static const int kCaptinFieldNumber = 2;
  inline bool captin() const;
  inline void set_captin(bool value);

  // optional int32 pos_x = 3;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 3;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // optional int32 pos_y = 4;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 4;
  inline ::google::protobuf::int32 pos_y() const;
  inline void set_pos_y(::google::protobuf::int32 value);

  // optional int32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.Member)
 private:
  inline void set_has_hero_id();
  inline void clear_has_hero_id();
  inline void set_has_captin();
  inline void clear_has_captin();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 hero_id_;
  bool captin_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Member* default_instance_;
};
// -------------------------------------------------------------------

class Opponent : public ::google::protobuf::Message {
 public:
  Opponent();
  virtual ~Opponent();

  Opponent(const Opponent& from);

  inline Opponent& operator=(const Opponent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Opponent& default_instance();

  void Swap(Opponent* other);

  // implements Message ----------------------------------------------

  Opponent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Opponent& from);
  void MergeFrom(const Opponent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 role_id() const;
  inline void set_role_id(::google::protobuf::int32 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional int32 role_thumb = 6;
  inline bool has_role_thumb() const;
  inline void clear_role_thumb();
  static const int kRoleThumbFieldNumber = 6;
  inline ::google::protobuf::int32 role_thumb() const;
  inline void set_role_thumb(::google::protobuf::int32 value);

  // optional int32 role_lv = 3;
  inline bool has_role_lv() const;
  inline void clear_role_lv();
  static const int kRoleLvFieldNumber = 3;
  inline ::google::protobuf::int32 role_lv() const;
  inline void set_role_lv(::google::protobuf::int32 value);

  // optional int32 points = 4;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 4;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // optional int32 combat = 5;
  inline bool has_combat() const;
  inline void clear_combat();
  static const int kCombatFieldNumber = 5;
  inline ::google::protobuf::int32 combat() const;
  inline void set_combat(::google::protobuf::int32 value);

  // optional int32 hero_thumb = 7;
  inline bool has_hero_thumb() const;
  inline void clear_hero_thumb();
  static const int kHeroThumbFieldNumber = 7;
  inline ::google::protobuf::int32 hero_thumb() const;
  inline void set_hero_thumb(::google::protobuf::int32 value);

  // optional bool is_robot = 8;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 8;
  inline bool is_robot() const;
  inline void set_is_robot(bool value);

  // optional string fb_id = 9;
  inline bool has_fb_id() const;
  inline void clear_fb_id();
  static const int kFbIdFieldNumber = 9;
  inline const ::std::string& fb_id() const;
  inline void set_fb_id(const ::std::string& value);
  inline void set_fb_id(const char* value);
  inline void set_fb_id(const char* value, size_t size);
  inline ::std::string* mutable_fb_id();
  inline ::std::string* release_fb_id();
  inline void set_allocated_fb_id(::std::string* fb_id);

  // @@protoc_insertion_point(class_scope:protos.Opponent)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_thumb();
  inline void clear_has_role_thumb();
  inline void set_has_role_lv();
  inline void clear_has_role_lv();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_combat();
  inline void clear_has_combat();
  inline void set_has_hero_thumb();
  inline void clear_has_hero_thumb();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();
  inline void set_has_fb_id();
  inline void clear_has_fb_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::int32 role_id_;
  ::google::protobuf::int32 role_thumb_;
  ::google::protobuf::int32 role_lv_;
  ::google::protobuf::int32 points_;
  ::google::protobuf::int32 combat_;
  ::google::protobuf::int32 hero_thumb_;
  ::std::string* fb_id_;
  bool is_robot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Opponent* default_instance_;
};
// -------------------------------------------------------------------

class PvpPrize : public ::google::protobuf::Message {
 public:
  PvpPrize();
  virtual ~PvpPrize();

  PvpPrize(const PvpPrize& from);

  inline PvpPrize& operator=(const PvpPrize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpPrize& default_instance();

  void Swap(PvpPrize* other);

  // implements Message ----------------------------------------------

  PvpPrize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpPrize& from);
  void MergeFrom(const PvpPrize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int32 points = 2;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // repeated .protos.common.Prize prizes = 3;
  inline int prizes_size() const;
  inline void clear_prizes();
  static const int kPrizesFieldNumber = 3;
  inline const ::protos::common::Prize& prizes(int index) const;
  inline ::protos::common::Prize* mutable_prizes(int index);
  inline ::protos::common::Prize* add_prizes();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >&
      prizes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >*
      mutable_prizes();

  // @@protoc_insertion_point(class_scope:protos.PvpPrize)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_points();
  inline void clear_has_points();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 points_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Prize > prizes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpPrize* default_instance_;
};
// ===================================================================


// ===================================================================

// PvpTeamData

// required int32 status = 1;
inline bool PvpTeamData::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpTeamData::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpTeamData::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpTeamData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PvpTeamData::status() const {
  return status_;
}
inline void PvpTeamData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .protos.Member team = 2;
inline int PvpTeamData::team_size() const {
  return team_.size();
}
inline void PvpTeamData::clear_team() {
  team_.Clear();
}
inline const ::protos::Member& PvpTeamData::team(int index) const {
  return team_.Get(index);
}
inline ::protos::Member* PvpTeamData::mutable_team(int index) {
  return team_.Mutable(index);
}
inline ::protos::Member* PvpTeamData::add_team() {
  return team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::Member >&
PvpTeamData::team() const {
  return team_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::Member >*
PvpTeamData::mutable_team() {
  return &team_;
}

// -------------------------------------------------------------------

// PvpDataReq

// required bool refresh = 1;
inline bool PvpDataReq::has_refresh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpDataReq::set_has_refresh() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpDataReq::clear_has_refresh() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpDataReq::clear_refresh() {
  refresh_ = false;
  clear_has_refresh();
}
inline bool PvpDataReq::refresh() const {
  return refresh_;
}
inline void PvpDataReq::set_refresh(bool value) {
  set_has_refresh();
  refresh_ = value;
}

// -------------------------------------------------------------------

// PvpDataRes

// optional int32 max_time = 1;
inline bool PvpDataRes::has_max_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpDataRes::set_has_max_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpDataRes::clear_has_max_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpDataRes::clear_max_time() {
  max_time_ = 0;
  clear_has_max_time();
}
inline ::google::protobuf::int32 PvpDataRes::max_time() const {
  return max_time_;
}
inline void PvpDataRes::set_max_time(::google::protobuf::int32 value) {
  set_has_max_time();
  max_time_ = value;
}

// optional int32 now_time = 2;
inline bool PvpDataRes::has_now_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpDataRes::set_has_now_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpDataRes::clear_has_now_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpDataRes::clear_now_time() {
  now_time_ = 0;
  clear_has_now_time();
}
inline ::google::protobuf::int32 PvpDataRes::now_time() const {
  return now_time_;
}
inline void PvpDataRes::set_now_time(::google::protobuf::int32 value) {
  set_has_now_time();
  now_time_ = value;
}

// repeated .protos.Opponent opponents = 3;
inline int PvpDataRes::opponents_size() const {
  return opponents_.size();
}
inline void PvpDataRes::clear_opponents() {
  opponents_.Clear();
}
inline const ::protos::Opponent& PvpDataRes::opponents(int index) const {
  return opponents_.Get(index);
}
inline ::protos::Opponent* PvpDataRes::mutable_opponents(int index) {
  return opponents_.Mutable(index);
}
inline ::protos::Opponent* PvpDataRes::add_opponents() {
  return opponents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::Opponent >&
PvpDataRes::opponents() const {
  return opponents_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::Opponent >*
PvpDataRes::mutable_opponents() {
  return &opponents_;
}

// optional .protos.PvpPrize prize = 4;
inline bool PvpDataRes::has_prize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpDataRes::set_has_prize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpDataRes::clear_has_prize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpDataRes::clear_prize() {
  if (prize_ != NULL) prize_->::protos::PvpPrize::Clear();
  clear_has_prize();
}
inline const ::protos::PvpPrize& PvpDataRes::prize() const {
  return prize_ != NULL ? *prize_ : *default_instance_->prize_;
}
inline ::protos::PvpPrize* PvpDataRes::mutable_prize() {
  set_has_prize();
  if (prize_ == NULL) prize_ = new ::protos::PvpPrize;
  return prize_;
}
inline ::protos::PvpPrize* PvpDataRes::release_prize() {
  clear_has_prize();
  ::protos::PvpPrize* temp = prize_;
  prize_ = NULL;
  return temp;
}
inline void PvpDataRes::set_allocated_prize(::protos::PvpPrize* prize) {
  delete prize_;
  prize_ = prize;
  if (prize) {
    set_has_prize();
  } else {
    clear_has_prize();
  }
}

// optional int32 cd_time = 5;
inline bool PvpDataRes::has_cd_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpDataRes::set_has_cd_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpDataRes::clear_has_cd_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpDataRes::clear_cd_time() {
  cd_time_ = 0;
  clear_has_cd_time();
}
inline ::google::protobuf::int32 PvpDataRes::cd_time() const {
  return cd_time_;
}
inline void PvpDataRes::set_cd_time(::google::protobuf::int32 value) {
  set_has_cd_time();
  cd_time_ = value;
}

// -------------------------------------------------------------------

// PvpPrizeList

// repeated .protos.PvpPrize prize_list = 1;
inline int PvpPrizeList::prize_list_size() const {
  return prize_list_.size();
}
inline void PvpPrizeList::clear_prize_list() {
  prize_list_.Clear();
}
inline const ::protos::PvpPrize& PvpPrizeList::prize_list(int index) const {
  return prize_list_.Get(index);
}
inline ::protos::PvpPrize* PvpPrizeList::mutable_prize_list(int index) {
  return prize_list_.Mutable(index);
}
inline ::protos::PvpPrize* PvpPrizeList::add_prize_list() {
  return prize_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >&
PvpPrizeList::prize_list() const {
  return prize_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >*
PvpPrizeList::mutable_prize_list() {
  return &prize_list_;
}

// -------------------------------------------------------------------

// OppTeamReq

// required int32 role_id = 1;
inline bool OppTeamReq::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OppTeamReq::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OppTeamReq::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OppTeamReq::clear_role_id() {
  role_id_ = 0;
  clear_has_role_id();
}
inline ::google::protobuf::int32 OppTeamReq::role_id() const {
  return role_id_;
}
inline void OppTeamReq::set_role_id(::google::protobuf::int32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required bool is_robot = 2;
inline bool OppTeamReq::has_is_robot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OppTeamReq::set_has_is_robot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OppTeamReq::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OppTeamReq::clear_is_robot() {
  is_robot_ = false;
  clear_has_is_robot();
}
inline bool OppTeamReq::is_robot() const {
  return is_robot_;
}
inline void OppTeamReq::set_is_robot(bool value) {
  set_has_is_robot();
  is_robot_ = value;
}

// -------------------------------------------------------------------

// OppTeamRes

// required int32 result = 1;
inline bool OppTeamRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OppTeamRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OppTeamRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OppTeamRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 OppTeamRes::result() const {
  return result_;
}
inline void OppTeamRes::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 captin_skill_id = 2;
inline bool OppTeamRes::has_captin_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OppTeamRes::set_has_captin_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OppTeamRes::clear_has_captin_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OppTeamRes::clear_captin_skill_id() {
  captin_skill_id_ = 0;
  clear_has_captin_skill_id();
}
inline ::google::protobuf::int32 OppTeamRes::captin_skill_id() const {
  return captin_skill_id_;
}
inline void OppTeamRes::set_captin_skill_id(::google::protobuf::int32 value) {
  set_has_captin_skill_id();
  captin_skill_id_ = value;
}

// repeated .protos.common.Hero hero_list = 3;
inline int OppTeamRes::hero_list_size() const {
  return hero_list_.size();
}
inline void OppTeamRes::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::protos::common::Hero& OppTeamRes::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::protos::common::Hero* OppTeamRes::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::protos::common::Hero* OppTeamRes::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
OppTeamRes::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
OppTeamRes::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// Member

// required int32 hero_id = 1;
inline bool Member::has_hero_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_hero_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_hero_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_hero_id() {
  hero_id_ = 0;
  clear_has_hero_id();
}
inline ::google::protobuf::int32 Member::hero_id() const {
  return hero_id_;
}
inline void Member::set_hero_id(::google::protobuf::int32 value) {
  set_has_hero_id();
  hero_id_ = value;
}

// required bool captin = 2;
inline bool Member::has_captin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Member::set_has_captin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Member::clear_has_captin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Member::clear_captin() {
  captin_ = false;
  clear_has_captin();
}
inline bool Member::captin() const {
  return captin_;
}
inline void Member::set_captin(bool value) {
  set_has_captin();
  captin_ = value;
}

// optional int32 pos_x = 3;
inline bool Member::has_pos_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Member::set_has_pos_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Member::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Member::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 Member::pos_x() const {
  return pos_x_;
}
inline void Member::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional int32 pos_y = 4;
inline bool Member::has_pos_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Member::set_has_pos_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Member::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Member::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 Member::pos_y() const {
  return pos_y_;
}
inline void Member::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// optional int32 index = 5;
inline bool Member::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Member::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Member::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Member::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Member::index() const {
  return index_;
}
inline void Member::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// Opponent

// required int32 role_id = 1;
inline bool Opponent::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Opponent::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Opponent::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Opponent::clear_role_id() {
  role_id_ = 0;
  clear_has_role_id();
}
inline ::google::protobuf::int32 Opponent::role_id() const {
  return role_id_;
}
inline void Opponent::set_role_id(::google::protobuf::int32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 2;
inline bool Opponent::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Opponent::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Opponent::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Opponent::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& Opponent::role_name() const {
  return *role_name_;
}
inline void Opponent::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void Opponent::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void Opponent::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Opponent::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* Opponent::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Opponent::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 role_thumb = 6;
inline bool Opponent::has_role_thumb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Opponent::set_has_role_thumb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Opponent::clear_has_role_thumb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Opponent::clear_role_thumb() {
  role_thumb_ = 0;
  clear_has_role_thumb();
}
inline ::google::protobuf::int32 Opponent::role_thumb() const {
  return role_thumb_;
}
inline void Opponent::set_role_thumb(::google::protobuf::int32 value) {
  set_has_role_thumb();
  role_thumb_ = value;
}

// optional int32 role_lv = 3;
inline bool Opponent::has_role_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Opponent::set_has_role_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Opponent::clear_has_role_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Opponent::clear_role_lv() {
  role_lv_ = 0;
  clear_has_role_lv();
}
inline ::google::protobuf::int32 Opponent::role_lv() const {
  return role_lv_;
}
inline void Opponent::set_role_lv(::google::protobuf::int32 value) {
  set_has_role_lv();
  role_lv_ = value;
}

// optional int32 points = 4;
inline bool Opponent::has_points() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Opponent::set_has_points() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Opponent::clear_has_points() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Opponent::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 Opponent::points() const {
  return points_;
}
inline void Opponent::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// optional int32 combat = 5;
inline bool Opponent::has_combat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Opponent::set_has_combat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Opponent::clear_has_combat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Opponent::clear_combat() {
  combat_ = 0;
  clear_has_combat();
}
inline ::google::protobuf::int32 Opponent::combat() const {
  return combat_;
}
inline void Opponent::set_combat(::google::protobuf::int32 value) {
  set_has_combat();
  combat_ = value;
}

// optional int32 hero_thumb = 7;
inline bool Opponent::has_hero_thumb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Opponent::set_has_hero_thumb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Opponent::clear_has_hero_thumb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Opponent::clear_hero_thumb() {
  hero_thumb_ = 0;
  clear_has_hero_thumb();
}
inline ::google::protobuf::int32 Opponent::hero_thumb() const {
  return hero_thumb_;
}
inline void Opponent::set_hero_thumb(::google::protobuf::int32 value) {
  set_has_hero_thumb();
  hero_thumb_ = value;
}

// optional bool is_robot = 8;
inline bool Opponent::has_is_robot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Opponent::set_has_is_robot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Opponent::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Opponent::clear_is_robot() {
  is_robot_ = false;
  clear_has_is_robot();
}
inline bool Opponent::is_robot() const {
  return is_robot_;
}
inline void Opponent::set_is_robot(bool value) {
  set_has_is_robot();
  is_robot_ = value;
}

// optional string fb_id = 9;
inline bool Opponent::has_fb_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Opponent::set_has_fb_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Opponent::clear_has_fb_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Opponent::clear_fb_id() {
  if (fb_id_ != &::google::protobuf::internal::kEmptyString) {
    fb_id_->clear();
  }
  clear_has_fb_id();
}
inline const ::std::string& Opponent::fb_id() const {
  return *fb_id_;
}
inline void Opponent::set_fb_id(const ::std::string& value) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(value);
}
inline void Opponent::set_fb_id(const char* value) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(value);
}
inline void Opponent::set_fb_id(const char* value, size_t size) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Opponent::mutable_fb_id() {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  return fb_id_;
}
inline ::std::string* Opponent::release_fb_id() {
  clear_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fb_id_;
    fb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Opponent::set_allocated_fb_id(::std::string* fb_id) {
  if (fb_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_id_;
  }
  if (fb_id) {
    set_has_fb_id();
    fb_id_ = fb_id;
  } else {
    clear_has_fb_id();
    fb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PvpPrize

// optional int32 rank = 1;
inline bool PvpPrize::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpPrize::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpPrize::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpPrize::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 PvpPrize::rank() const {
  return rank_;
}
inline void PvpPrize::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int32 points = 2;
inline bool PvpPrize::has_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpPrize::set_has_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpPrize::clear_has_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpPrize::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 PvpPrize::points() const {
  return points_;
}
inline void PvpPrize::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// repeated .protos.common.Prize prizes = 3;
inline int PvpPrize::prizes_size() const {
  return prizes_.size();
}
inline void PvpPrize::clear_prizes() {
  prizes_.Clear();
}
inline const ::protos::common::Prize& PvpPrize::prizes(int index) const {
  return prizes_.Get(index);
}
inline ::protos::common::Prize* PvpPrize::mutable_prizes(int index) {
  return prizes_.Mutable(index);
}
inline ::protos::common::Prize* PvpPrize::add_prizes() {
  return prizes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >&
PvpPrize::prizes() const {
  return prizes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >*
PvpPrize::mutable_prizes() {
  return &prizes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pvp_5fprotocol_2eproto__INCLUDED
