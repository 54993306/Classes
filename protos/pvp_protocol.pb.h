// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pvp_protocol.proto

#ifndef PROTOBUF_pvp_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_pvp_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/prize_common.pb.h"
#include "common/hero_common.pb.h"
#include "common/monster_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

class PvpTeamData;
class PvpDataReq;
class PvpDataRes;
class PvpPrizeList;
class OppTeamReq;
class OppTeamRes;
class StartPvpReq;
class StartPvpRes;
class PvpOverReq;
class PvpOverRes;
class PvpRecordRes;
class Record;
class RecordData;
class Member;
class Opponent;
class PvpPrize;

// ===================================================================

class PvpTeamData : public ::google::protobuf::Message {
 public:
  PvpTeamData();
  virtual ~PvpTeamData();

  PvpTeamData(const PvpTeamData& from);

  inline PvpTeamData& operator=(const PvpTeamData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpTeamData& default_instance();

  void Swap(PvpTeamData* other);

  // implements Message ----------------------------------------------

  PvpTeamData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpTeamData& from);
  void MergeFrom(const PvpTeamData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .protos.Member team = 2;
  inline int team_size() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 2;
  inline const ::protos::Member& team(int index) const;
  inline ::protos::Member* mutable_team(int index);
  inline ::protos::Member* add_team();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::Member >&
      team() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::Member >*
      mutable_team();

  // @@protoc_insertion_point(class_scope:protos.PvpTeamData)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protos::Member > team_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpTeamData* default_instance_;
};
// -------------------------------------------------------------------

class PvpDataReq : public ::google::protobuf::Message {
 public:
  PvpDataReq();
  virtual ~PvpDataReq();

  PvpDataReq(const PvpDataReq& from);

  inline PvpDataReq& operator=(const PvpDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpDataReq& default_instance();

  void Swap(PvpDataReq* other);

  // implements Message ----------------------------------------------

  PvpDataReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpDataReq& from);
  void MergeFrom(const PvpDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool refresh = 1;
  inline bool has_refresh() const;
  inline void clear_refresh();
  static const int kRefreshFieldNumber = 1;
  inline bool refresh() const;
  inline void set_refresh(bool value);

  // @@protoc_insertion_point(class_scope:protos.PvpDataReq)
 private:
  inline void set_has_refresh();
  inline void clear_has_refresh();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool refresh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpDataReq* default_instance_;
};
// -------------------------------------------------------------------

class PvpDataRes : public ::google::protobuf::Message {
 public:
  PvpDataRes();
  virtual ~PvpDataRes();

  PvpDataRes(const PvpDataRes& from);

  inline PvpDataRes& operator=(const PvpDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpDataRes& default_instance();

  void Swap(PvpDataRes* other);

  // implements Message ----------------------------------------------

  PvpDataRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpDataRes& from);
  void MergeFrom(const PvpDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 max_time = 1;
  inline bool has_max_time() const;
  inline void clear_max_time();
  static const int kMaxTimeFieldNumber = 1;
  inline ::google::protobuf::int32 max_time() const;
  inline void set_max_time(::google::protobuf::int32 value);

  // optional int32 now_time = 2;
  inline bool has_now_time() const;
  inline void clear_now_time();
  static const int kNowTimeFieldNumber = 2;
  inline ::google::protobuf::int32 now_time() const;
  inline void set_now_time(::google::protobuf::int32 value);

  // repeated .protos.Opponent opponents = 3;
  inline int opponents_size() const;
  inline void clear_opponents();
  static const int kOpponentsFieldNumber = 3;
  inline const ::protos::Opponent& opponents(int index) const;
  inline ::protos::Opponent* mutable_opponents(int index);
  inline ::protos::Opponent* add_opponents();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::Opponent >&
      opponents() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::Opponent >*
      mutable_opponents();

  // optional .protos.PvpPrize prize = 4;
  inline bool has_prize() const;
  inline void clear_prize();
  static const int kPrizeFieldNumber = 4;
  inline const ::protos::PvpPrize& prize() const;
  inline ::protos::PvpPrize* mutable_prize();
  inline ::protos::PvpPrize* release_prize();
  inline void set_allocated_prize(::protos::PvpPrize* prize);

  // optional int32 cd_time = 5;
  inline bool has_cd_time() const;
  inline void clear_cd_time();
  static const int kCdTimeFieldNumber = 5;
  inline ::google::protobuf::int32 cd_time() const;
  inline void set_cd_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.PvpDataRes)
 private:
  inline void set_has_max_time();
  inline void clear_has_max_time();
  inline void set_has_now_time();
  inline void clear_has_now_time();
  inline void set_has_prize();
  inline void clear_has_prize();
  inline void set_has_cd_time();
  inline void clear_has_cd_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 max_time_;
  ::google::protobuf::int32 now_time_;
  ::google::protobuf::RepeatedPtrField< ::protos::Opponent > opponents_;
  ::protos::PvpPrize* prize_;
  ::google::protobuf::int32 cd_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpDataRes* default_instance_;
};
// -------------------------------------------------------------------

class PvpPrizeList : public ::google::protobuf::Message {
 public:
  PvpPrizeList();
  virtual ~PvpPrizeList();

  PvpPrizeList(const PvpPrizeList& from);

  inline PvpPrizeList& operator=(const PvpPrizeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpPrizeList& default_instance();

  void Swap(PvpPrizeList* other);

  // implements Message ----------------------------------------------

  PvpPrizeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpPrizeList& from);
  void MergeFrom(const PvpPrizeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protos.PvpPrize prize_list = 1;
  inline int prize_list_size() const;
  inline void clear_prize_list();
  static const int kPrizeListFieldNumber = 1;
  inline const ::protos::PvpPrize& prize_list(int index) const;
  inline ::protos::PvpPrize* mutable_prize_list(int index);
  inline ::protos::PvpPrize* add_prize_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >&
      prize_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >*
      mutable_prize_list();

  // @@protoc_insertion_point(class_scope:protos.PvpPrizeList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize > prize_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpPrizeList* default_instance_;
};
// -------------------------------------------------------------------

class OppTeamReq : public ::google::protobuf::Message {
 public:
  OppTeamReq();
  virtual ~OppTeamReq();

  OppTeamReq(const OppTeamReq& from);

  inline OppTeamReq& operator=(const OppTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OppTeamReq& default_instance();

  void Swap(OppTeamReq* other);

  // implements Message ----------------------------------------------

  OppTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OppTeamReq& from);
  void MergeFrom(const OppTeamReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 role_id() const;
  inline void set_role_id(::google::protobuf::int32 value);

  // required bool is_robot = 2;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 2;
  inline bool is_robot() const;
  inline void set_is_robot(bool value);

  // @@protoc_insertion_point(class_scope:protos.OppTeamReq)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 role_id_;
  bool is_robot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static OppTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class OppTeamRes : public ::google::protobuf::Message {
 public:
  OppTeamRes();
  virtual ~OppTeamRes();

  OppTeamRes(const OppTeamRes& from);

  inline OppTeamRes& operator=(const OppTeamRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OppTeamRes& default_instance();

  void Swap(OppTeamRes* other);

  // implements Message ----------------------------------------------

  OppTeamRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OppTeamRes& from);
  void MergeFrom(const OppTeamRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 captin_skill_id = 2;
  inline bool has_captin_skill_id() const;
  inline void clear_captin_skill_id();
  static const int kCaptinSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 captin_skill_id() const;
  inline void set_captin_skill_id(::google::protobuf::int32 value);

  // repeated .protos.common.Hero hero_list = 3;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 3;
  inline const ::protos::common::Hero& hero_list(int index) const;
  inline ::protos::common::Hero* mutable_hero_list(int index);
  inline ::protos::common::Hero* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
      mutable_hero_list();

  // optional int32 team_combat = 4;
  inline bool has_team_combat() const;
  inline void clear_team_combat();
  static const int kTeamCombatFieldNumber = 4;
  inline ::google::protobuf::int32 team_combat() const;
  inline void set_team_combat(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.OppTeamRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_captin_skill_id();
  inline void clear_has_captin_skill_id();
  inline void set_has_team_combat();
  inline void clear_has_team_combat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 captin_skill_id_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Hero > hero_list_;
  ::google::protobuf::int32 team_combat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static OppTeamRes* default_instance_;
};
// -------------------------------------------------------------------

class StartPvpReq : public ::google::protobuf::Message {
 public:
  StartPvpReq();
  virtual ~StartPvpReq();

  StartPvpReq(const StartPvpReq& from);

  inline StartPvpReq& operator=(const StartPvpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartPvpReq& default_instance();

  void Swap(StartPvpReq* other);

  // implements Message ----------------------------------------------

  StartPvpReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartPvpReq& from);
  void MergeFrom(const StartPvpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 opp_id = 1;
  inline bool has_opp_id() const;
  inline void clear_opp_id();
  static const int kOppIdFieldNumber = 1;
  inline ::google::protobuf::int32 opp_id() const;
  inline void set_opp_id(::google::protobuf::int32 value);

  // required bool is_robot = 2;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 2;
  inline bool is_robot() const;
  inline void set_is_robot(bool value);

  // repeated int32 battle_hero = 3 [packed = true];
  inline int battle_hero_size() const;
  inline void clear_battle_hero();
  static const int kBattleHeroFieldNumber = 3;
  inline ::google::protobuf::int32 battle_hero(int index) const;
  inline void set_battle_hero(int index, ::google::protobuf::int32 value);
  inline void add_battle_hero(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      battle_hero() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_battle_hero();

  // optional bool reven = 4;
  inline bool has_reven() const;
  inline void clear_reven();
  static const int kRevenFieldNumber = 4;
  inline bool reven() const;
  inline void set_reven(bool value);

  // @@protoc_insertion_point(class_scope:protos.StartPvpReq)
 private:
  inline void set_has_opp_id();
  inline void clear_has_opp_id();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();
  inline void set_has_reven();
  inline void clear_has_reven();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opp_id_;
  bool is_robot_;
  bool reven_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > battle_hero_;
  mutable int _battle_hero_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static StartPvpReq* default_instance_;
};
// -------------------------------------------------------------------

class StartPvpRes : public ::google::protobuf::Message {
 public:
  StartPvpRes();
  virtual ~StartPvpRes();

  StartPvpRes(const StartPvpRes& from);

  inline StartPvpRes& operator=(const StartPvpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartPvpRes& default_instance();

  void Swap(StartPvpRes* other);

  // implements Message ----------------------------------------------

  StartPvpRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartPvpRes& from);
  void MergeFrom(const StartPvpRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline bool result() const;
  inline void set_result(bool value);

  // optional int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .protos.common.Hero opponents = 2;
  inline int opponents_size() const;
  inline void clear_opponents();
  static const int kOpponentsFieldNumber = 2;
  inline const ::protos::common::Hero& opponents(int index) const;
  inline ::protos::common::Hero* mutable_opponents(int index);
  inline ::protos::common::Hero* add_opponents();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
      opponents() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
      mutable_opponents();

  // repeated .protos.common.Hero hero_list = 3;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 3;
  inline const ::protos::common::Hero& hero_list(int index) const;
  inline ::protos::common::Hero* mutable_hero_list(int index);
  inline ::protos::common::Hero* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
      mutable_hero_list();

  // repeated .protos.common.Monster call_monster = 4;
  inline int call_monster_size() const;
  inline void clear_call_monster();
  static const int kCallMonsterFieldNumber = 4;
  inline const ::protos::common::Monster& call_monster(int index) const;
  inline ::protos::common::Monster* mutable_call_monster(int index);
  inline ::protos::common::Monster* add_call_monster();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Monster >&
      call_monster() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Monster >*
      mutable_call_monster();

  // @@protoc_insertion_point(class_scope:protos.StartPvpRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool result_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Hero > opponents_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Hero > hero_list_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Monster > call_monster_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static StartPvpRes* default_instance_;
};
// -------------------------------------------------------------------

class PvpOverReq : public ::google::protobuf::Message {
 public:
  PvpOverReq();
  virtual ~PvpOverReq();

  PvpOverReq(const PvpOverReq& from);

  inline PvpOverReq& operator=(const PvpOverReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpOverReq& default_instance();

  void Swap(PvpOverReq* other);

  // implements Message ----------------------------------------------

  PvpOverReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpOverReq& from);
  void MergeFrom(const PvpOverReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool battle_result = 1;
  inline bool has_battle_result() const;
  inline void clear_battle_result();
  static const int kBattleResultFieldNumber = 1;
  inline bool battle_result() const;
  inline void set_battle_result(bool value);

  // optional int32 battle_time = 2;
  inline bool has_battle_time() const;
  inline void clear_battle_time();
  static const int kBattleTimeFieldNumber = 2;
  inline ::google::protobuf::int32 battle_time() const;
  inline void set_battle_time(::google::protobuf::int32 value);

  // optional int32 blood_1 = 3;
  inline bool has_blood_1() const;
  inline void clear_blood_1();
  static const int kBlood1FieldNumber = 3;
  inline ::google::protobuf::int32 blood_1() const;
  inline void set_blood_1(::google::protobuf::int32 value);

  // optional int32 blood_2 = 4;
  inline bool has_blood_2() const;
  inline void clear_blood_2();
  static const int kBlood2FieldNumber = 4;
  inline ::google::protobuf::int32 blood_2() const;
  inline void set_blood_2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.PvpOverReq)
 private:
  inline void set_has_battle_result();
  inline void clear_has_battle_result();
  inline void set_has_battle_time();
  inline void clear_has_battle_time();
  inline void set_has_blood_1();
  inline void clear_has_blood_1();
  inline void set_has_blood_2();
  inline void clear_has_blood_2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool battle_result_;
  ::google::protobuf::int32 battle_time_;
  ::google::protobuf::int32 blood_1_;
  ::google::protobuf::int32 blood_2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpOverReq* default_instance_;
};
// -------------------------------------------------------------------

class PvpOverRes : public ::google::protobuf::Message {
 public:
  PvpOverRes();
  virtual ~PvpOverRes();

  PvpOverRes(const PvpOverRes& from);

  inline PvpOverRes& operator=(const PvpOverRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpOverRes& default_instance();

  void Swap(PvpOverRes* other);

  // implements Message ----------------------------------------------

  PvpOverRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpOverRes& from);
  void MergeFrom(const PvpOverRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 org_points = 2;
  inline bool has_org_points() const;
  inline void clear_org_points();
  static const int kOrgPointsFieldNumber = 2;
  inline ::google::protobuf::int32 org_points() const;
  inline void set_org_points(::google::protobuf::int32 value);

  // optional sint32 add_points = 3;
  inline bool has_add_points() const;
  inline void clear_add_points();
  static const int kAddPointsFieldNumber = 3;
  inline ::google::protobuf::int32 add_points() const;
  inline void set_add_points(::google::protobuf::int32 value);

  // optional int32 pvp_coin = 4;
  inline bool has_pvp_coin() const;
  inline void clear_pvp_coin();
  static const int kPvpCoinFieldNumber = 4;
  inline ::google::protobuf::int32 pvp_coin() const;
  inline void set_pvp_coin(::google::protobuf::int32 value);

  // optional .protos.Opponent next_rank = 5;
  inline bool has_next_rank() const;
  inline void clear_next_rank();
  static const int kNextRankFieldNumber = 5;
  inline const ::protos::Opponent& next_rank() const;
  inline ::protos::Opponent* mutable_next_rank();
  inline ::protos::Opponent* release_next_rank();
  inline void set_allocated_next_rank(::protos::Opponent* next_rank);

  // optional int32 my_rank = 6;
  inline bool has_my_rank() const;
  inline void clear_my_rank();
  static const int kMyRankFieldNumber = 6;
  inline ::google::protobuf::int32 my_rank() const;
  inline void set_my_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.PvpOverRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_org_points();
  inline void clear_has_org_points();
  inline void set_has_add_points();
  inline void clear_has_add_points();
  inline void set_has_pvp_coin();
  inline void clear_has_pvp_coin();
  inline void set_has_next_rank();
  inline void clear_has_next_rank();
  inline void set_has_my_rank();
  inline void clear_has_my_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 org_points_;
  ::google::protobuf::int32 add_points_;
  ::google::protobuf::int32 pvp_coin_;
  ::protos::Opponent* next_rank_;
  ::google::protobuf::int32 my_rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpOverRes* default_instance_;
};
// -------------------------------------------------------------------

class PvpRecordRes : public ::google::protobuf::Message {
 public:
  PvpRecordRes();
  virtual ~PvpRecordRes();

  PvpRecordRes(const PvpRecordRes& from);

  inline PvpRecordRes& operator=(const PvpRecordRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpRecordRes& default_instance();

  void Swap(PvpRecordRes* other);

  // implements Message ----------------------------------------------

  PvpRecordRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpRecordRes& from);
  void MergeFrom(const PvpRecordRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protos.Record record_list = 1;
  inline int record_list_size() const;
  inline void clear_record_list();
  static const int kRecordListFieldNumber = 1;
  inline const ::protos::Record& record_list(int index) const;
  inline ::protos::Record* mutable_record_list(int index);
  inline ::protos::Record* add_record_list();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::Record >&
      record_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::Record >*
      mutable_record_list();

  // optional int32 reven_time = 2;
  inline bool has_reven_time() const;
  inline void clear_reven_time();
  static const int kRevenTimeFieldNumber = 2;
  inline ::google::protobuf::int32 reven_time() const;
  inline void set_reven_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.PvpRecordRes)
 private:
  inline void set_has_reven_time();
  inline void clear_has_reven_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protos::Record > record_list_;
  ::google::protobuf::int32 reven_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpRecordRes* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  Record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 record_id = 1;
  inline bool has_record_id() const;
  inline void clear_record_id();
  static const int kRecordIdFieldNumber = 1;
  inline ::google::protobuf::int32 record_id() const;
  inline void set_record_id(::google::protobuf::int32 value);

  // optional int32 battle_time = 2;
  inline bool has_battle_time() const;
  inline void clear_battle_time();
  static const int kBattleTimeFieldNumber = 2;
  inline ::google::protobuf::int32 battle_time() const;
  inline void set_battle_time(::google::protobuf::int32 value);

  // optional .protos.RecordData player1 = 3;
  inline bool has_player1() const;
  inline void clear_player1();
  static const int kPlayer1FieldNumber = 3;
  inline const ::protos::RecordData& player1() const;
  inline ::protos::RecordData* mutable_player1();
  inline ::protos::RecordData* release_player1();
  inline void set_allocated_player1(::protos::RecordData* player1);

  // optional .protos.RecordData player2 = 4;
  inline bool has_player2() const;
  inline void clear_player2();
  static const int kPlayer2FieldNumber = 4;
  inline const ::protos::RecordData& player2() const;
  inline ::protos::RecordData* mutable_player2();
  inline ::protos::RecordData* release_player2();
  inline void set_allocated_player2(::protos::RecordData* player2);

  // @@protoc_insertion_point(class_scope:protos.Record)
 private:
  inline void set_has_record_id();
  inline void clear_has_record_id();
  inline void set_has_battle_time();
  inline void clear_has_battle_time();
  inline void set_has_player1();
  inline void clear_has_player1();
  inline void set_has_player2();
  inline void clear_has_player2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 record_id_;
  ::google::protobuf::int32 battle_time_;
  ::protos::RecordData* player1_;
  ::protos::RecordData* player2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// -------------------------------------------------------------------

class RecordData : public ::google::protobuf::Message {
 public:
  RecordData();
  virtual ~RecordData();

  RecordData(const RecordData& from);

  inline RecordData& operator=(const RecordData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordData& default_instance();

  void Swap(RecordData* other);

  // implements Message ----------------------------------------------

  RecordData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordData& from);
  void MergeFrom(const RecordData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 role_thumb = 1;
  inline bool has_role_thumb() const;
  inline void clear_role_thumb();
  static const int kRoleThumbFieldNumber = 1;
  inline ::google::protobuf::int32 role_thumb() const;
  inline void set_role_thumb(::google::protobuf::int32 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional int32 role_level = 3;
  inline bool has_role_level() const;
  inline void clear_role_level();
  static const int kRoleLevelFieldNumber = 3;
  inline ::google::protobuf::int32 role_level() const;
  inline void set_role_level(::google::protobuf::int32 value);

  // optional sint32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // repeated .protos.common.Hero teams = 5;
  inline int teams_size() const;
  inline void clear_teams();
  static const int kTeamsFieldNumber = 5;
  inline const ::protos::common::Hero& teams(int index) const;
  inline ::protos::common::Hero* mutable_teams(int index);
  inline ::protos::common::Hero* add_teams();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
      teams() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
      mutable_teams();

  // optional string fb_id = 6;
  inline bool has_fb_id() const;
  inline void clear_fb_id();
  static const int kFbIdFieldNumber = 6;
  inline const ::std::string& fb_id() const;
  inline void set_fb_id(const ::std::string& value);
  inline void set_fb_id(const char* value);
  inline void set_fb_id(const char* value, size_t size);
  inline ::std::string* mutable_fb_id();
  inline ::std::string* release_fb_id();
  inline void set_allocated_fb_id(::std::string* fb_id);

  // @@protoc_insertion_point(class_scope:protos.RecordData)
 private:
  inline void set_has_role_thumb();
  inline void clear_has_role_thumb();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_level();
  inline void clear_has_role_level();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_fb_id();
  inline void clear_has_fb_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::int32 role_thumb_;
  ::google::protobuf::int32 role_level_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Hero > teams_;
  ::std::string* fb_id_;
  ::google::protobuf::int32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static RecordData* default_instance_;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::Message {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Member& default_instance();

  void Swap(Member* other);

  // implements Message ----------------------------------------------

  Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 hero_id = 1;
  inline bool has_hero_id() const;
  inline void clear_hero_id();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::int32 hero_id() const;
  inline void set_hero_id(::google::protobuf::int32 value);

  // required bool captin = 2;
  inline bool has_captin() const;
  inline void clear_captin();
  static const int kCaptinFieldNumber = 2;
  inline bool captin() const;
  inline void set_captin(bool value);

  // optional int32 pos_x = 3;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 3;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // optional int32 pos_y = 4;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 4;
  inline ::google::protobuf::int32 pos_y() const;
  inline void set_pos_y(::google::protobuf::int32 value);

  // optional int32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.Member)
 private:
  inline void set_has_hero_id();
  inline void clear_has_hero_id();
  inline void set_has_captin();
  inline void clear_has_captin();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 hero_id_;
  bool captin_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Member* default_instance_;
};
// -------------------------------------------------------------------

class Opponent : public ::google::protobuf::Message {
 public:
  Opponent();
  virtual ~Opponent();

  Opponent(const Opponent& from);

  inline Opponent& operator=(const Opponent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Opponent& default_instance();

  void Swap(Opponent* other);

  // implements Message ----------------------------------------------

  Opponent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Opponent& from);
  void MergeFrom(const Opponent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int32 role_id() const;
  inline void set_role_id(::google::protobuf::int32 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional int32 role_thumb = 6;
  inline bool has_role_thumb() const;
  inline void clear_role_thumb();
  static const int kRoleThumbFieldNumber = 6;
  inline ::google::protobuf::int32 role_thumb() const;
  inline void set_role_thumb(::google::protobuf::int32 value);

  // optional int32 role_lv = 3;
  inline bool has_role_lv() const;
  inline void clear_role_lv();
  static const int kRoleLvFieldNumber = 3;
  inline ::google::protobuf::int32 role_lv() const;
  inline void set_role_lv(::google::protobuf::int32 value);

  // optional int32 points = 4;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 4;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // optional int32 combat = 5;
  inline bool has_combat() const;
  inline void clear_combat();
  static const int kCombatFieldNumber = 5;
  inline ::google::protobuf::int32 combat() const;
  inline void set_combat(::google::protobuf::int32 value);

  // optional int32 hero_thumb = 7;
  inline bool has_hero_thumb() const;
  inline void clear_hero_thumb();
  static const int kHeroThumbFieldNumber = 7;
  inline ::google::protobuf::int32 hero_thumb() const;
  inline void set_hero_thumb(::google::protobuf::int32 value);

  // optional bool is_robot = 8;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 8;
  inline bool is_robot() const;
  inline void set_is_robot(bool value);

  // optional string fb_id = 9;
  inline bool has_fb_id() const;
  inline void clear_fb_id();
  static const int kFbIdFieldNumber = 9;
  inline const ::std::string& fb_id() const;
  inline void set_fb_id(const ::std::string& value);
  inline void set_fb_id(const char* value);
  inline void set_fb_id(const char* value, size_t size);
  inline ::std::string* mutable_fb_id();
  inline ::std::string* release_fb_id();
  inline void set_allocated_fb_id(::std::string* fb_id);

  // optional int32 rank = 10;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 10;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.Opponent)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_thumb();
  inline void clear_has_role_thumb();
  inline void set_has_role_lv();
  inline void clear_has_role_lv();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_combat();
  inline void clear_has_combat();
  inline void set_has_hero_thumb();
  inline void clear_has_hero_thumb();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();
  inline void set_has_fb_id();
  inline void clear_has_fb_id();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::int32 role_id_;
  ::google::protobuf::int32 role_thumb_;
  ::google::protobuf::int32 role_lv_;
  ::google::protobuf::int32 points_;
  ::google::protobuf::int32 combat_;
  ::google::protobuf::int32 hero_thumb_;
  ::std::string* fb_id_;
  bool is_robot_;
  ::google::protobuf::int32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Opponent* default_instance_;
};
// -------------------------------------------------------------------

class PvpPrize : public ::google::protobuf::Message {
 public:
  PvpPrize();
  virtual ~PvpPrize();

  PvpPrize(const PvpPrize& from);

  inline PvpPrize& operator=(const PvpPrize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpPrize& default_instance();

  void Swap(PvpPrize* other);

  // implements Message ----------------------------------------------

  PvpPrize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpPrize& from);
  void MergeFrom(const PvpPrize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int32 points = 2;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // repeated .protos.common.Prize prizes = 3;
  inline int prizes_size() const;
  inline void clear_prizes();
  static const int kPrizesFieldNumber = 3;
  inline const ::protos::common::Prize& prizes(int index) const;
  inline ::protos::common::Prize* mutable_prizes(int index);
  inline ::protos::common::Prize* add_prizes();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >&
      prizes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >*
      mutable_prizes();

  // @@protoc_insertion_point(class_scope:protos.PvpPrize)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_points();
  inline void clear_has_points();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 points_;
  ::google::protobuf::RepeatedPtrField< ::protos::common::Prize > prizes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_pvp_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_pvp_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static PvpPrize* default_instance_;
};
// ===================================================================


// ===================================================================

// PvpTeamData

// required int32 status = 1;
inline bool PvpTeamData::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpTeamData::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpTeamData::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpTeamData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PvpTeamData::status() const {
  return status_;
}
inline void PvpTeamData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .protos.Member team = 2;
inline int PvpTeamData::team_size() const {
  return team_.size();
}
inline void PvpTeamData::clear_team() {
  team_.Clear();
}
inline const ::protos::Member& PvpTeamData::team(int index) const {
  return team_.Get(index);
}
inline ::protos::Member* PvpTeamData::mutable_team(int index) {
  return team_.Mutable(index);
}
inline ::protos::Member* PvpTeamData::add_team() {
  return team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::Member >&
PvpTeamData::team() const {
  return team_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::Member >*
PvpTeamData::mutable_team() {
  return &team_;
}

// -------------------------------------------------------------------

// PvpDataReq

// required bool refresh = 1;
inline bool PvpDataReq::has_refresh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpDataReq::set_has_refresh() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpDataReq::clear_has_refresh() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpDataReq::clear_refresh() {
  refresh_ = false;
  clear_has_refresh();
}
inline bool PvpDataReq::refresh() const {
  return refresh_;
}
inline void PvpDataReq::set_refresh(bool value) {
  set_has_refresh();
  refresh_ = value;
}

// -------------------------------------------------------------------

// PvpDataRes

// optional int32 max_time = 1;
inline bool PvpDataRes::has_max_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpDataRes::set_has_max_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpDataRes::clear_has_max_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpDataRes::clear_max_time() {
  max_time_ = 0;
  clear_has_max_time();
}
inline ::google::protobuf::int32 PvpDataRes::max_time() const {
  return max_time_;
}
inline void PvpDataRes::set_max_time(::google::protobuf::int32 value) {
  set_has_max_time();
  max_time_ = value;
}

// optional int32 now_time = 2;
inline bool PvpDataRes::has_now_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpDataRes::set_has_now_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpDataRes::clear_has_now_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpDataRes::clear_now_time() {
  now_time_ = 0;
  clear_has_now_time();
}
inline ::google::protobuf::int32 PvpDataRes::now_time() const {
  return now_time_;
}
inline void PvpDataRes::set_now_time(::google::protobuf::int32 value) {
  set_has_now_time();
  now_time_ = value;
}

// repeated .protos.Opponent opponents = 3;
inline int PvpDataRes::opponents_size() const {
  return opponents_.size();
}
inline void PvpDataRes::clear_opponents() {
  opponents_.Clear();
}
inline const ::protos::Opponent& PvpDataRes::opponents(int index) const {
  return opponents_.Get(index);
}
inline ::protos::Opponent* PvpDataRes::mutable_opponents(int index) {
  return opponents_.Mutable(index);
}
inline ::protos::Opponent* PvpDataRes::add_opponents() {
  return opponents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::Opponent >&
PvpDataRes::opponents() const {
  return opponents_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::Opponent >*
PvpDataRes::mutable_opponents() {
  return &opponents_;
}

// optional .protos.PvpPrize prize = 4;
inline bool PvpDataRes::has_prize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpDataRes::set_has_prize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpDataRes::clear_has_prize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpDataRes::clear_prize() {
  if (prize_ != NULL) prize_->::protos::PvpPrize::Clear();
  clear_has_prize();
}
inline const ::protos::PvpPrize& PvpDataRes::prize() const {
  return prize_ != NULL ? *prize_ : *default_instance_->prize_;
}
inline ::protos::PvpPrize* PvpDataRes::mutable_prize() {
  set_has_prize();
  if (prize_ == NULL) prize_ = new ::protos::PvpPrize;
  return prize_;
}
inline ::protos::PvpPrize* PvpDataRes::release_prize() {
  clear_has_prize();
  ::protos::PvpPrize* temp = prize_;
  prize_ = NULL;
  return temp;
}
inline void PvpDataRes::set_allocated_prize(::protos::PvpPrize* prize) {
  delete prize_;
  prize_ = prize;
  if (prize) {
    set_has_prize();
  } else {
    clear_has_prize();
  }
}

// optional int32 cd_time = 5;
inline bool PvpDataRes::has_cd_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpDataRes::set_has_cd_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpDataRes::clear_has_cd_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpDataRes::clear_cd_time() {
  cd_time_ = 0;
  clear_has_cd_time();
}
inline ::google::protobuf::int32 PvpDataRes::cd_time() const {
  return cd_time_;
}
inline void PvpDataRes::set_cd_time(::google::protobuf::int32 value) {
  set_has_cd_time();
  cd_time_ = value;
}

// -------------------------------------------------------------------

// PvpPrizeList

// repeated .protos.PvpPrize prize_list = 1;
inline int PvpPrizeList::prize_list_size() const {
  return prize_list_.size();
}
inline void PvpPrizeList::clear_prize_list() {
  prize_list_.Clear();
}
inline const ::protos::PvpPrize& PvpPrizeList::prize_list(int index) const {
  return prize_list_.Get(index);
}
inline ::protos::PvpPrize* PvpPrizeList::mutable_prize_list(int index) {
  return prize_list_.Mutable(index);
}
inline ::protos::PvpPrize* PvpPrizeList::add_prize_list() {
  return prize_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >&
PvpPrizeList::prize_list() const {
  return prize_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::PvpPrize >*
PvpPrizeList::mutable_prize_list() {
  return &prize_list_;
}

// -------------------------------------------------------------------

// OppTeamReq

// required int32 role_id = 1;
inline bool OppTeamReq::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OppTeamReq::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OppTeamReq::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OppTeamReq::clear_role_id() {
  role_id_ = 0;
  clear_has_role_id();
}
inline ::google::protobuf::int32 OppTeamReq::role_id() const {
  return role_id_;
}
inline void OppTeamReq::set_role_id(::google::protobuf::int32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required bool is_robot = 2;
inline bool OppTeamReq::has_is_robot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OppTeamReq::set_has_is_robot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OppTeamReq::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OppTeamReq::clear_is_robot() {
  is_robot_ = false;
  clear_has_is_robot();
}
inline bool OppTeamReq::is_robot() const {
  return is_robot_;
}
inline void OppTeamReq::set_is_robot(bool value) {
  set_has_is_robot();
  is_robot_ = value;
}

// -------------------------------------------------------------------

// OppTeamRes

// required int32 result = 1;
inline bool OppTeamRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OppTeamRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OppTeamRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OppTeamRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 OppTeamRes::result() const {
  return result_;
}
inline void OppTeamRes::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 captin_skill_id = 2;
inline bool OppTeamRes::has_captin_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OppTeamRes::set_has_captin_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OppTeamRes::clear_has_captin_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OppTeamRes::clear_captin_skill_id() {
  captin_skill_id_ = 0;
  clear_has_captin_skill_id();
}
inline ::google::protobuf::int32 OppTeamRes::captin_skill_id() const {
  return captin_skill_id_;
}
inline void OppTeamRes::set_captin_skill_id(::google::protobuf::int32 value) {
  set_has_captin_skill_id();
  captin_skill_id_ = value;
}

// repeated .protos.common.Hero hero_list = 3;
inline int OppTeamRes::hero_list_size() const {
  return hero_list_.size();
}
inline void OppTeamRes::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::protos::common::Hero& OppTeamRes::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::protos::common::Hero* OppTeamRes::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::protos::common::Hero* OppTeamRes::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
OppTeamRes::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
OppTeamRes::mutable_hero_list() {
  return &hero_list_;
}

// optional int32 team_combat = 4;
inline bool OppTeamRes::has_team_combat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OppTeamRes::set_has_team_combat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OppTeamRes::clear_has_team_combat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OppTeamRes::clear_team_combat() {
  team_combat_ = 0;
  clear_has_team_combat();
}
inline ::google::protobuf::int32 OppTeamRes::team_combat() const {
  return team_combat_;
}
inline void OppTeamRes::set_team_combat(::google::protobuf::int32 value) {
  set_has_team_combat();
  team_combat_ = value;
}

// -------------------------------------------------------------------

// StartPvpReq

// required int32 opp_id = 1;
inline bool StartPvpReq::has_opp_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPvpReq::set_has_opp_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPvpReq::clear_has_opp_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPvpReq::clear_opp_id() {
  opp_id_ = 0;
  clear_has_opp_id();
}
inline ::google::protobuf::int32 StartPvpReq::opp_id() const {
  return opp_id_;
}
inline void StartPvpReq::set_opp_id(::google::protobuf::int32 value) {
  set_has_opp_id();
  opp_id_ = value;
}

// required bool is_robot = 2;
inline bool StartPvpReq::has_is_robot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartPvpReq::set_has_is_robot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartPvpReq::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartPvpReq::clear_is_robot() {
  is_robot_ = false;
  clear_has_is_robot();
}
inline bool StartPvpReq::is_robot() const {
  return is_robot_;
}
inline void StartPvpReq::set_is_robot(bool value) {
  set_has_is_robot();
  is_robot_ = value;
}

// repeated int32 battle_hero = 3 [packed = true];
inline int StartPvpReq::battle_hero_size() const {
  return battle_hero_.size();
}
inline void StartPvpReq::clear_battle_hero() {
  battle_hero_.Clear();
}
inline ::google::protobuf::int32 StartPvpReq::battle_hero(int index) const {
  return battle_hero_.Get(index);
}
inline void StartPvpReq::set_battle_hero(int index, ::google::protobuf::int32 value) {
  battle_hero_.Set(index, value);
}
inline void StartPvpReq::add_battle_hero(::google::protobuf::int32 value) {
  battle_hero_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
StartPvpReq::battle_hero() const {
  return battle_hero_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
StartPvpReq::mutable_battle_hero() {
  return &battle_hero_;
}

// optional bool reven = 4;
inline bool StartPvpReq::has_reven() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartPvpReq::set_has_reven() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartPvpReq::clear_has_reven() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartPvpReq::clear_reven() {
  reven_ = false;
  clear_has_reven();
}
inline bool StartPvpReq::reven() const {
  return reven_;
}
inline void StartPvpReq::set_reven(bool value) {
  set_has_reven();
  reven_ = value;
}

// -------------------------------------------------------------------

// StartPvpRes

// required bool result = 5;
inline bool StartPvpRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPvpRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPvpRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPvpRes::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool StartPvpRes::result() const {
  return result_;
}
inline void StartPvpRes::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional int32 status = 1;
inline bool StartPvpRes::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartPvpRes::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartPvpRes::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartPvpRes::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 StartPvpRes::status() const {
  return status_;
}
inline void StartPvpRes::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .protos.common.Hero opponents = 2;
inline int StartPvpRes::opponents_size() const {
  return opponents_.size();
}
inline void StartPvpRes::clear_opponents() {
  opponents_.Clear();
}
inline const ::protos::common::Hero& StartPvpRes::opponents(int index) const {
  return opponents_.Get(index);
}
inline ::protos::common::Hero* StartPvpRes::mutable_opponents(int index) {
  return opponents_.Mutable(index);
}
inline ::protos::common::Hero* StartPvpRes::add_opponents() {
  return opponents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
StartPvpRes::opponents() const {
  return opponents_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
StartPvpRes::mutable_opponents() {
  return &opponents_;
}

// repeated .protos.common.Hero hero_list = 3;
inline int StartPvpRes::hero_list_size() const {
  return hero_list_.size();
}
inline void StartPvpRes::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::protos::common::Hero& StartPvpRes::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::protos::common::Hero* StartPvpRes::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::protos::common::Hero* StartPvpRes::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
StartPvpRes::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
StartPvpRes::mutable_hero_list() {
  return &hero_list_;
}

// repeated .protos.common.Monster call_monster = 4;
inline int StartPvpRes::call_monster_size() const {
  return call_monster_.size();
}
inline void StartPvpRes::clear_call_monster() {
  call_monster_.Clear();
}
inline const ::protos::common::Monster& StartPvpRes::call_monster(int index) const {
  return call_monster_.Get(index);
}
inline ::protos::common::Monster* StartPvpRes::mutable_call_monster(int index) {
  return call_monster_.Mutable(index);
}
inline ::protos::common::Monster* StartPvpRes::add_call_monster() {
  return call_monster_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Monster >&
StartPvpRes::call_monster() const {
  return call_monster_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Monster >*
StartPvpRes::mutable_call_monster() {
  return &call_monster_;
}

// -------------------------------------------------------------------

// PvpOverReq

// required bool battle_result = 1;
inline bool PvpOverReq::has_battle_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpOverReq::set_has_battle_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpOverReq::clear_has_battle_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpOverReq::clear_battle_result() {
  battle_result_ = false;
  clear_has_battle_result();
}
inline bool PvpOverReq::battle_result() const {
  return battle_result_;
}
inline void PvpOverReq::set_battle_result(bool value) {
  set_has_battle_result();
  battle_result_ = value;
}

// optional int32 battle_time = 2;
inline bool PvpOverReq::has_battle_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpOverReq::set_has_battle_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpOverReq::clear_has_battle_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpOverReq::clear_battle_time() {
  battle_time_ = 0;
  clear_has_battle_time();
}
inline ::google::protobuf::int32 PvpOverReq::battle_time() const {
  return battle_time_;
}
inline void PvpOverReq::set_battle_time(::google::protobuf::int32 value) {
  set_has_battle_time();
  battle_time_ = value;
}

// optional int32 blood_1 = 3;
inline bool PvpOverReq::has_blood_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpOverReq::set_has_blood_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpOverReq::clear_has_blood_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpOverReq::clear_blood_1() {
  blood_1_ = 0;
  clear_has_blood_1();
}
inline ::google::protobuf::int32 PvpOverReq::blood_1() const {
  return blood_1_;
}
inline void PvpOverReq::set_blood_1(::google::protobuf::int32 value) {
  set_has_blood_1();
  blood_1_ = value;
}

// optional int32 blood_2 = 4;
inline bool PvpOverReq::has_blood_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpOverReq::set_has_blood_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpOverReq::clear_has_blood_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpOverReq::clear_blood_2() {
  blood_2_ = 0;
  clear_has_blood_2();
}
inline ::google::protobuf::int32 PvpOverReq::blood_2() const {
  return blood_2_;
}
inline void PvpOverReq::set_blood_2(::google::protobuf::int32 value) {
  set_has_blood_2();
  blood_2_ = value;
}

// -------------------------------------------------------------------

// PvpOverRes

// required int32 result = 1;
inline bool PvpOverRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpOverRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpOverRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpOverRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PvpOverRes::result() const {
  return result_;
}
inline void PvpOverRes::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 org_points = 2;
inline bool PvpOverRes::has_org_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpOverRes::set_has_org_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpOverRes::clear_has_org_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpOverRes::clear_org_points() {
  org_points_ = 0;
  clear_has_org_points();
}
inline ::google::protobuf::int32 PvpOverRes::org_points() const {
  return org_points_;
}
inline void PvpOverRes::set_org_points(::google::protobuf::int32 value) {
  set_has_org_points();
  org_points_ = value;
}

// optional sint32 add_points = 3;
inline bool PvpOverRes::has_add_points() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpOverRes::set_has_add_points() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpOverRes::clear_has_add_points() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpOverRes::clear_add_points() {
  add_points_ = 0;
  clear_has_add_points();
}
inline ::google::protobuf::int32 PvpOverRes::add_points() const {
  return add_points_;
}
inline void PvpOverRes::set_add_points(::google::protobuf::int32 value) {
  set_has_add_points();
  add_points_ = value;
}

// optional int32 pvp_coin = 4;
inline bool PvpOverRes::has_pvp_coin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpOverRes::set_has_pvp_coin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpOverRes::clear_has_pvp_coin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpOverRes::clear_pvp_coin() {
  pvp_coin_ = 0;
  clear_has_pvp_coin();
}
inline ::google::protobuf::int32 PvpOverRes::pvp_coin() const {
  return pvp_coin_;
}
inline void PvpOverRes::set_pvp_coin(::google::protobuf::int32 value) {
  set_has_pvp_coin();
  pvp_coin_ = value;
}

// optional .protos.Opponent next_rank = 5;
inline bool PvpOverRes::has_next_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpOverRes::set_has_next_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpOverRes::clear_has_next_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpOverRes::clear_next_rank() {
  if (next_rank_ != NULL) next_rank_->::protos::Opponent::Clear();
  clear_has_next_rank();
}
inline const ::protos::Opponent& PvpOverRes::next_rank() const {
  return next_rank_ != NULL ? *next_rank_ : *default_instance_->next_rank_;
}
inline ::protos::Opponent* PvpOverRes::mutable_next_rank() {
  set_has_next_rank();
  if (next_rank_ == NULL) next_rank_ = new ::protos::Opponent;
  return next_rank_;
}
inline ::protos::Opponent* PvpOverRes::release_next_rank() {
  clear_has_next_rank();
  ::protos::Opponent* temp = next_rank_;
  next_rank_ = NULL;
  return temp;
}
inline void PvpOverRes::set_allocated_next_rank(::protos::Opponent* next_rank) {
  delete next_rank_;
  next_rank_ = next_rank;
  if (next_rank) {
    set_has_next_rank();
  } else {
    clear_has_next_rank();
  }
}

// optional int32 my_rank = 6;
inline bool PvpOverRes::has_my_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PvpOverRes::set_has_my_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PvpOverRes::clear_has_my_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PvpOverRes::clear_my_rank() {
  my_rank_ = 0;
  clear_has_my_rank();
}
inline ::google::protobuf::int32 PvpOverRes::my_rank() const {
  return my_rank_;
}
inline void PvpOverRes::set_my_rank(::google::protobuf::int32 value) {
  set_has_my_rank();
  my_rank_ = value;
}

// -------------------------------------------------------------------

// PvpRecordRes

// repeated .protos.Record record_list = 1;
inline int PvpRecordRes::record_list_size() const {
  return record_list_.size();
}
inline void PvpRecordRes::clear_record_list() {
  record_list_.Clear();
}
inline const ::protos::Record& PvpRecordRes::record_list(int index) const {
  return record_list_.Get(index);
}
inline ::protos::Record* PvpRecordRes::mutable_record_list(int index) {
  return record_list_.Mutable(index);
}
inline ::protos::Record* PvpRecordRes::add_record_list() {
  return record_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::Record >&
PvpRecordRes::record_list() const {
  return record_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::Record >*
PvpRecordRes::mutable_record_list() {
  return &record_list_;
}

// optional int32 reven_time = 2;
inline bool PvpRecordRes::has_reven_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpRecordRes::set_has_reven_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpRecordRes::clear_has_reven_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpRecordRes::clear_reven_time() {
  reven_time_ = 0;
  clear_has_reven_time();
}
inline ::google::protobuf::int32 PvpRecordRes::reven_time() const {
  return reven_time_;
}
inline void PvpRecordRes::set_reven_time(::google::protobuf::int32 value) {
  set_has_reven_time();
  reven_time_ = value;
}

// -------------------------------------------------------------------

// Record

// optional int32 record_id = 1;
inline bool Record::has_record_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record::set_has_record_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record::clear_has_record_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record::clear_record_id() {
  record_id_ = 0;
  clear_has_record_id();
}
inline ::google::protobuf::int32 Record::record_id() const {
  return record_id_;
}
inline void Record::set_record_id(::google::protobuf::int32 value) {
  set_has_record_id();
  record_id_ = value;
}

// optional int32 battle_time = 2;
inline bool Record::has_battle_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record::set_has_battle_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record::clear_has_battle_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record::clear_battle_time() {
  battle_time_ = 0;
  clear_has_battle_time();
}
inline ::google::protobuf::int32 Record::battle_time() const {
  return battle_time_;
}
inline void Record::set_battle_time(::google::protobuf::int32 value) {
  set_has_battle_time();
  battle_time_ = value;
}

// optional .protos.RecordData player1 = 3;
inline bool Record::has_player1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record::set_has_player1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record::clear_has_player1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record::clear_player1() {
  if (player1_ != NULL) player1_->::protos::RecordData::Clear();
  clear_has_player1();
}
inline const ::protos::RecordData& Record::player1() const {
  return player1_ != NULL ? *player1_ : *default_instance_->player1_;
}
inline ::protos::RecordData* Record::mutable_player1() {
  set_has_player1();
  if (player1_ == NULL) player1_ = new ::protos::RecordData;
  return player1_;
}
inline ::protos::RecordData* Record::release_player1() {
  clear_has_player1();
  ::protos::RecordData* temp = player1_;
  player1_ = NULL;
  return temp;
}
inline void Record::set_allocated_player1(::protos::RecordData* player1) {
  delete player1_;
  player1_ = player1;
  if (player1) {
    set_has_player1();
  } else {
    clear_has_player1();
  }
}

// optional .protos.RecordData player2 = 4;
inline bool Record::has_player2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record::set_has_player2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record::clear_has_player2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record::clear_player2() {
  if (player2_ != NULL) player2_->::protos::RecordData::Clear();
  clear_has_player2();
}
inline const ::protos::RecordData& Record::player2() const {
  return player2_ != NULL ? *player2_ : *default_instance_->player2_;
}
inline ::protos::RecordData* Record::mutable_player2() {
  set_has_player2();
  if (player2_ == NULL) player2_ = new ::protos::RecordData;
  return player2_;
}
inline ::protos::RecordData* Record::release_player2() {
  clear_has_player2();
  ::protos::RecordData* temp = player2_;
  player2_ = NULL;
  return temp;
}
inline void Record::set_allocated_player2(::protos::RecordData* player2) {
  delete player2_;
  player2_ = player2;
  if (player2) {
    set_has_player2();
  } else {
    clear_has_player2();
  }
}

// -------------------------------------------------------------------

// RecordData

// optional int32 role_thumb = 1;
inline bool RecordData::has_role_thumb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordData::set_has_role_thumb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordData::clear_has_role_thumb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordData::clear_role_thumb() {
  role_thumb_ = 0;
  clear_has_role_thumb();
}
inline ::google::protobuf::int32 RecordData::role_thumb() const {
  return role_thumb_;
}
inline void RecordData::set_role_thumb(::google::protobuf::int32 value) {
  set_has_role_thumb();
  role_thumb_ = value;
}

// optional string role_name = 2;
inline bool RecordData::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordData::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordData::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordData::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& RecordData::role_name() const {
  return *role_name_;
}
inline void RecordData::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void RecordData::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void RecordData::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordData::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* RecordData::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecordData::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 role_level = 3;
inline bool RecordData::has_role_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordData::set_has_role_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordData::clear_has_role_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordData::clear_role_level() {
  role_level_ = 0;
  clear_has_role_level();
}
inline ::google::protobuf::int32 RecordData::role_level() const {
  return role_level_;
}
inline void RecordData::set_role_level(::google::protobuf::int32 value) {
  set_has_role_level();
  role_level_ = value;
}

// optional sint32 rank = 4;
inline bool RecordData::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordData::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordData::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordData::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 RecordData::rank() const {
  return rank_;
}
inline void RecordData::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// repeated .protos.common.Hero teams = 5;
inline int RecordData::teams_size() const {
  return teams_.size();
}
inline void RecordData::clear_teams() {
  teams_.Clear();
}
inline const ::protos::common::Hero& RecordData::teams(int index) const {
  return teams_.Get(index);
}
inline ::protos::common::Hero* RecordData::mutable_teams(int index) {
  return teams_.Mutable(index);
}
inline ::protos::common::Hero* RecordData::add_teams() {
  return teams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >&
RecordData::teams() const {
  return teams_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Hero >*
RecordData::mutable_teams() {
  return &teams_;
}

// optional string fb_id = 6;
inline bool RecordData::has_fb_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecordData::set_has_fb_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecordData::clear_has_fb_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecordData::clear_fb_id() {
  if (fb_id_ != &::google::protobuf::internal::kEmptyString) {
    fb_id_->clear();
  }
  clear_has_fb_id();
}
inline const ::std::string& RecordData::fb_id() const {
  return *fb_id_;
}
inline void RecordData::set_fb_id(const ::std::string& value) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(value);
}
inline void RecordData::set_fb_id(const char* value) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(value);
}
inline void RecordData::set_fb_id(const char* value, size_t size) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordData::mutable_fb_id() {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  return fb_id_;
}
inline ::std::string* RecordData::release_fb_id() {
  clear_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fb_id_;
    fb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecordData::set_allocated_fb_id(::std::string* fb_id) {
  if (fb_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_id_;
  }
  if (fb_id) {
    set_has_fb_id();
    fb_id_ = fb_id;
  } else {
    clear_has_fb_id();
    fb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Member

// required int32 hero_id = 1;
inline bool Member::has_hero_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_hero_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_hero_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_hero_id() {
  hero_id_ = 0;
  clear_has_hero_id();
}
inline ::google::protobuf::int32 Member::hero_id() const {
  return hero_id_;
}
inline void Member::set_hero_id(::google::protobuf::int32 value) {
  set_has_hero_id();
  hero_id_ = value;
}

// required bool captin = 2;
inline bool Member::has_captin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Member::set_has_captin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Member::clear_has_captin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Member::clear_captin() {
  captin_ = false;
  clear_has_captin();
}
inline bool Member::captin() const {
  return captin_;
}
inline void Member::set_captin(bool value) {
  set_has_captin();
  captin_ = value;
}

// optional int32 pos_x = 3;
inline bool Member::has_pos_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Member::set_has_pos_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Member::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Member::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 Member::pos_x() const {
  return pos_x_;
}
inline void Member::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional int32 pos_y = 4;
inline bool Member::has_pos_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Member::set_has_pos_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Member::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Member::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 Member::pos_y() const {
  return pos_y_;
}
inline void Member::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// optional int32 index = 5;
inline bool Member::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Member::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Member::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Member::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Member::index() const {
  return index_;
}
inline void Member::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// Opponent

// required int32 role_id = 1;
inline bool Opponent::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Opponent::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Opponent::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Opponent::clear_role_id() {
  role_id_ = 0;
  clear_has_role_id();
}
inline ::google::protobuf::int32 Opponent::role_id() const {
  return role_id_;
}
inline void Opponent::set_role_id(::google::protobuf::int32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 2;
inline bool Opponent::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Opponent::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Opponent::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Opponent::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& Opponent::role_name() const {
  return *role_name_;
}
inline void Opponent::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void Opponent::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void Opponent::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Opponent::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* Opponent::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Opponent::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 role_thumb = 6;
inline bool Opponent::has_role_thumb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Opponent::set_has_role_thumb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Opponent::clear_has_role_thumb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Opponent::clear_role_thumb() {
  role_thumb_ = 0;
  clear_has_role_thumb();
}
inline ::google::protobuf::int32 Opponent::role_thumb() const {
  return role_thumb_;
}
inline void Opponent::set_role_thumb(::google::protobuf::int32 value) {
  set_has_role_thumb();
  role_thumb_ = value;
}

// optional int32 role_lv = 3;
inline bool Opponent::has_role_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Opponent::set_has_role_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Opponent::clear_has_role_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Opponent::clear_role_lv() {
  role_lv_ = 0;
  clear_has_role_lv();
}
inline ::google::protobuf::int32 Opponent::role_lv() const {
  return role_lv_;
}
inline void Opponent::set_role_lv(::google::protobuf::int32 value) {
  set_has_role_lv();
  role_lv_ = value;
}

// optional int32 points = 4;
inline bool Opponent::has_points() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Opponent::set_has_points() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Opponent::clear_has_points() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Opponent::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 Opponent::points() const {
  return points_;
}
inline void Opponent::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// optional int32 combat = 5;
inline bool Opponent::has_combat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Opponent::set_has_combat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Opponent::clear_has_combat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Opponent::clear_combat() {
  combat_ = 0;
  clear_has_combat();
}
inline ::google::protobuf::int32 Opponent::combat() const {
  return combat_;
}
inline void Opponent::set_combat(::google::protobuf::int32 value) {
  set_has_combat();
  combat_ = value;
}

// optional int32 hero_thumb = 7;
inline bool Opponent::has_hero_thumb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Opponent::set_has_hero_thumb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Opponent::clear_has_hero_thumb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Opponent::clear_hero_thumb() {
  hero_thumb_ = 0;
  clear_has_hero_thumb();
}
inline ::google::protobuf::int32 Opponent::hero_thumb() const {
  return hero_thumb_;
}
inline void Opponent::set_hero_thumb(::google::protobuf::int32 value) {
  set_has_hero_thumb();
  hero_thumb_ = value;
}

// optional bool is_robot = 8;
inline bool Opponent::has_is_robot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Opponent::set_has_is_robot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Opponent::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Opponent::clear_is_robot() {
  is_robot_ = false;
  clear_has_is_robot();
}
inline bool Opponent::is_robot() const {
  return is_robot_;
}
inline void Opponent::set_is_robot(bool value) {
  set_has_is_robot();
  is_robot_ = value;
}

// optional string fb_id = 9;
inline bool Opponent::has_fb_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Opponent::set_has_fb_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Opponent::clear_has_fb_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Opponent::clear_fb_id() {
  if (fb_id_ != &::google::protobuf::internal::kEmptyString) {
    fb_id_->clear();
  }
  clear_has_fb_id();
}
inline const ::std::string& Opponent::fb_id() const {
  return *fb_id_;
}
inline void Opponent::set_fb_id(const ::std::string& value) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(value);
}
inline void Opponent::set_fb_id(const char* value) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(value);
}
inline void Opponent::set_fb_id(const char* value, size_t size) {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  fb_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Opponent::mutable_fb_id() {
  set_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    fb_id_ = new ::std::string;
  }
  return fb_id_;
}
inline ::std::string* Opponent::release_fb_id() {
  clear_has_fb_id();
  if (fb_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fb_id_;
    fb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Opponent::set_allocated_fb_id(::std::string* fb_id) {
  if (fb_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_id_;
  }
  if (fb_id) {
    set_has_fb_id();
    fb_id_ = fb_id;
  } else {
    clear_has_fb_id();
    fb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 rank = 10;
inline bool Opponent::has_rank() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Opponent::set_has_rank() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Opponent::clear_has_rank() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Opponent::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 Opponent::rank() const {
  return rank_;
}
inline void Opponent::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// -------------------------------------------------------------------

// PvpPrize

// optional int32 rank = 1;
inline bool PvpPrize::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpPrize::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpPrize::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpPrize::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 PvpPrize::rank() const {
  return rank_;
}
inline void PvpPrize::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int32 points = 2;
inline bool PvpPrize::has_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpPrize::set_has_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpPrize::clear_has_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpPrize::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 PvpPrize::points() const {
  return points_;
}
inline void PvpPrize::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// repeated .protos.common.Prize prizes = 3;
inline int PvpPrize::prizes_size() const {
  return prizes_.size();
}
inline void PvpPrize::clear_prizes() {
  prizes_.Clear();
}
inline const ::protos::common::Prize& PvpPrize::prizes(int index) const {
  return prizes_.Get(index);
}
inline ::protos::common::Prize* PvpPrize::mutable_prizes(int index) {
  return prizes_.Mutable(index);
}
inline ::protos::common::Prize* PvpPrize::add_prizes() {
  return prizes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >&
PvpPrize::prizes() const {
  return prizes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::common::Prize >*
PvpPrize::mutable_prizes() {
  return &prizes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pvp_5fprotocol_2eproto__INCLUDED
