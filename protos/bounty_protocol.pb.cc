// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bounty_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "bounty_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace protos {

namespace {

const ::google::protobuf::Descriptor* BountyDataRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BountyDataRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* HardModeReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HardModeReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* HardModeRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HardModeRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* Bounty_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Bounty_reflection_ = NULL;
const ::google::protobuf::Descriptor* BountyStage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BountyStage_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_bounty_5fprotocol_2eproto() {
  protobuf_AddDesc_bounty_5fprotocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "bounty_protocol.proto");
  GOOGLE_CHECK(file != NULL);
  BountyDataRes_descriptor_ = file->message_type(0);
  static const int BountyDataRes_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyDataRes, blist_),
  };
  BountyDataRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BountyDataRes_descriptor_,
      BountyDataRes::default_instance_,
      BountyDataRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyDataRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyDataRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BountyDataRes));
  HardModeReq_descriptor_ = file->message_type(1);
  static const int HardModeReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeReq, bid_),
  };
  HardModeReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HardModeReq_descriptor_,
      HardModeReq::default_instance_,
      HardModeReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HardModeReq));
  HardModeRes_descriptor_ = file->message_type(2);
  static const int HardModeRes_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeRes, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeRes, stage_),
  };
  HardModeRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HardModeRes_descriptor_,
      HardModeRes::default_instance_,
      HardModeRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardModeRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HardModeRes));
  Bounty_descriptor_ = file->message_type(3);
  static const int Bounty_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounty, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounty, endtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounty, openlevel_),
  };
  Bounty_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Bounty_descriptor_,
      Bounty::default_instance_,
      Bounty_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounty, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounty, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Bounty));
  BountyStage_descriptor_ = file->message_type(4);
  static const int BountyStage_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, hardmode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, openlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, isopen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, action_),
  };
  BountyStage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BountyStage_descriptor_,
      BountyStage::default_instance_,
      BountyStage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BountyStage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BountyStage));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_bounty_5fprotocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BountyDataRes_descriptor_, &BountyDataRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HardModeReq_descriptor_, &HardModeReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HardModeRes_descriptor_, &HardModeRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Bounty_descriptor_, &Bounty::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BountyStage_descriptor_, &BountyStage::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_bounty_5fprotocol_2eproto() {
  delete BountyDataRes::default_instance_;
  delete BountyDataRes_reflection_;
  delete HardModeReq::default_instance_;
  delete HardModeReq_reflection_;
  delete HardModeRes::default_instance_;
  delete HardModeRes_reflection_;
  delete Bounty::default_instance_;
  delete Bounty_reflection_;
  delete BountyStage::default_instance_;
  delete BountyStage_reflection_;
}

void protobuf_AddDesc_bounty_5fprotocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\025bounty_protocol.proto\022\006protos\".\n\rBount"
    "yDataRes\022\035\n\005blist\030\001 \003(\0132\016.protos.Bounty\""
    "\032\n\013HardModeReq\022\013\n\003bid\030\001 \002(\005\"A\n\013HardModeR"
    "es\022\016\n\006status\030\001 \002(\005\022\"\n\005stage\030\002 \003(\0132\023.prot"
    "os.BountyStage\"8\n\006Bounty\022\n\n\002id\030\001 \002(\005\022\017\n\007"
    "endTime\030\002 \001(\006\022\021\n\topenLevel\030\003 \001(\005\"^\n\013Boun"
    "tyStage\022\n\n\002id\030\001 \002(\005\022\020\n\010hardMode\030\002 \001(\005\022\021\n"
    "\topenLevel\030\003 \001(\005\022\016\n\006isOpen\030\004 \001(\010\022\016\n\006acti"
    "on\030\005 \001(\005B1\n\035dass.server.gameserver.proto"
    "sB\016BountyProtocolH\001", 379);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "bounty_protocol.proto", &protobuf_RegisterTypes);
  BountyDataRes::default_instance_ = new BountyDataRes();
  HardModeReq::default_instance_ = new HardModeReq();
  HardModeRes::default_instance_ = new HardModeRes();
  Bounty::default_instance_ = new Bounty();
  BountyStage::default_instance_ = new BountyStage();
  BountyDataRes::default_instance_->InitAsDefaultInstance();
  HardModeReq::default_instance_->InitAsDefaultInstance();
  HardModeRes::default_instance_->InitAsDefaultInstance();
  Bounty::default_instance_->InitAsDefaultInstance();
  BountyStage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_bounty_5fprotocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_bounty_5fprotocol_2eproto {
  StaticDescriptorInitializer_bounty_5fprotocol_2eproto() {
    protobuf_AddDesc_bounty_5fprotocol_2eproto();
  }
} static_descriptor_initializer_bounty_5fprotocol_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int BountyDataRes::kBlistFieldNumber;
#endif  // !_MSC_VER

BountyDataRes::BountyDataRes()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BountyDataRes::InitAsDefaultInstance() {
}

BountyDataRes::BountyDataRes(const BountyDataRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BountyDataRes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BountyDataRes::~BountyDataRes() {
  SharedDtor();
}

void BountyDataRes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BountyDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BountyDataRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BountyDataRes_descriptor_;
}

const BountyDataRes& BountyDataRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bounty_5fprotocol_2eproto();
  return *default_instance_;
}

BountyDataRes* BountyDataRes::default_instance_ = NULL;

BountyDataRes* BountyDataRes::New() const {
  return new BountyDataRes;
}

void BountyDataRes::Clear() {
  blist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BountyDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protos.Bounty blist = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_blist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_blist;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BountyDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .protos.Bounty blist = 1;
  for (int i = 0; i < this->blist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->blist(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BountyDataRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .protos.Bounty blist = 1;
  for (int i = 0; i < this->blist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->blist(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BountyDataRes::ByteSize() const {
  int total_size = 0;

  // repeated .protos.Bounty blist = 1;
  total_size += 1 * this->blist_size();
  for (int i = 0; i < this->blist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BountyDataRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BountyDataRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BountyDataRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BountyDataRes::MergeFrom(const BountyDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  blist_.MergeFrom(from.blist_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BountyDataRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BountyDataRes::CopyFrom(const BountyDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BountyDataRes::IsInitialized() const {

  for (int i = 0; i < blist_size(); i++) {
    if (!this->blist(i).IsInitialized()) return false;
  }
  return true;
}

void BountyDataRes::Swap(BountyDataRes* other) {
  if (other != this) {
    blist_.Swap(&other->blist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BountyDataRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BountyDataRes_descriptor_;
  metadata.reflection = BountyDataRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HardModeReq::kBidFieldNumber;
#endif  // !_MSC_VER

HardModeReq::HardModeReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HardModeReq::InitAsDefaultInstance() {
}

HardModeReq::HardModeReq(const HardModeReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HardModeReq::SharedCtor() {
  _cached_size_ = 0;
  bid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HardModeReq::~HardModeReq() {
  SharedDtor();
}

void HardModeReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HardModeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HardModeReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HardModeReq_descriptor_;
}

const HardModeReq& HardModeReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bounty_5fprotocol_2eproto();
  return *default_instance_;
}

HardModeReq* HardModeReq::default_instance_ = NULL;

HardModeReq* HardModeReq::New() const {
  return new HardModeReq;
}

void HardModeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HardModeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 bid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bid_)));
          set_has_bid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HardModeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 bid = 1;
  if (has_bid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HardModeReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 bid = 1;
  if (has_bid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->bid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HardModeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 bid = 1;
    if (has_bid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HardModeReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HardModeReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HardModeReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HardModeReq::MergeFrom(const HardModeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bid()) {
      set_bid(from.bid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HardModeReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HardModeReq::CopyFrom(const HardModeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HardModeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HardModeReq::Swap(HardModeReq* other) {
  if (other != this) {
    std::swap(bid_, other->bid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HardModeReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HardModeReq_descriptor_;
  metadata.reflection = HardModeReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HardModeRes::kStatusFieldNumber;
const int HardModeRes::kStageFieldNumber;
#endif  // !_MSC_VER

HardModeRes::HardModeRes()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HardModeRes::InitAsDefaultInstance() {
}

HardModeRes::HardModeRes(const HardModeRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HardModeRes::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HardModeRes::~HardModeRes() {
  SharedDtor();
}

void HardModeRes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HardModeRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HardModeRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HardModeRes_descriptor_;
}

const HardModeRes& HardModeRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bounty_5fprotocol_2eproto();
  return *default_instance_;
}

HardModeRes* HardModeRes::default_instance_ = NULL;

HardModeRes* HardModeRes::New() const {
  return new HardModeRes;
}

void HardModeRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  stage_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HardModeRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stage;
        break;
      }

      // repeated .protos.BountyStage stage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stage;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HardModeRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // repeated .protos.BountyStage stage = 2;
  for (int i = 0; i < this->stage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->stage(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HardModeRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->status(), target);
  }

  // repeated .protos.BountyStage stage = 2;
  for (int i = 0; i < this->stage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->stage(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HardModeRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  // repeated .protos.BountyStage stage = 2;
  total_size += 1 * this->stage_size();
  for (int i = 0; i < this->stage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stage(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HardModeRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HardModeRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HardModeRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HardModeRes::MergeFrom(const HardModeRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  stage_.MergeFrom(from.stage_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HardModeRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HardModeRes::CopyFrom(const HardModeRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HardModeRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < stage_size(); i++) {
    if (!this->stage(i).IsInitialized()) return false;
  }
  return true;
}

void HardModeRes::Swap(HardModeRes* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    stage_.Swap(&other->stage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HardModeRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HardModeRes_descriptor_;
  metadata.reflection = HardModeRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Bounty::kIdFieldNumber;
const int Bounty::kEndTimeFieldNumber;
const int Bounty::kOpenLevelFieldNumber;
#endif  // !_MSC_VER

Bounty::Bounty()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Bounty::InitAsDefaultInstance() {
}

Bounty::Bounty(const Bounty& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Bounty::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  endtime_ = GOOGLE_ULONGLONG(0);
  openlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Bounty::~Bounty() {
  SharedDtor();
}

void Bounty::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Bounty::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Bounty::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Bounty_descriptor_;
}

const Bounty& Bounty::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bounty_5fprotocol_2eproto();
  return *default_instance_;
}

Bounty* Bounty::default_instance_ = NULL;

Bounty* Bounty::New() const {
  return new Bounty;
}

void Bounty::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    endtime_ = GOOGLE_ULONGLONG(0);
    openlevel_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Bounty::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_endTime;
        break;
      }

      // optional fixed64 endTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_openLevel;
        break;
      }

      // optional int32 openLevel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_openLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &openlevel_)));
          set_has_openlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Bounty::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional fixed64 endTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(2, this->endtime(), output);
  }

  // optional int32 openLevel = 3;
  if (has_openlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->openlevel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Bounty::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional fixed64 endTime = 2;
  if (has_endtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(2, this->endtime(), target);
  }

  // optional int32 openLevel = 3;
  if (has_openlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->openlevel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Bounty::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional fixed64 endTime = 2;
    if (has_endtime()) {
      total_size += 1 + 8;
    }

    // optional int32 openLevel = 3;
    if (has_openlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->openlevel());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Bounty::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Bounty* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Bounty*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Bounty::MergeFrom(const Bounty& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_openlevel()) {
      set_openlevel(from.openlevel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Bounty::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Bounty::CopyFrom(const Bounty& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bounty::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Bounty::Swap(Bounty* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(endtime_, other->endtime_);
    std::swap(openlevel_, other->openlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Bounty::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Bounty_descriptor_;
  metadata.reflection = Bounty_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BountyStage::kIdFieldNumber;
const int BountyStage::kHardModeFieldNumber;
const int BountyStage::kOpenLevelFieldNumber;
const int BountyStage::kIsOpenFieldNumber;
const int BountyStage::kActionFieldNumber;
#endif  // !_MSC_VER

BountyStage::BountyStage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BountyStage::InitAsDefaultInstance() {
}

BountyStage::BountyStage(const BountyStage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BountyStage::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  hardmode_ = 0;
  openlevel_ = 0;
  isopen_ = false;
  action_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BountyStage::~BountyStage() {
  SharedDtor();
}

void BountyStage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BountyStage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BountyStage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BountyStage_descriptor_;
}

const BountyStage& BountyStage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bounty_5fprotocol_2eproto();
  return *default_instance_;
}

BountyStage* BountyStage::default_instance_ = NULL;

BountyStage* BountyStage::New() const {
  return new BountyStage;
}

void BountyStage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    hardmode_ = 0;
    openlevel_ = 0;
    isopen_ = false;
    action_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BountyStage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_hardMode;
        break;
      }

      // optional int32 hardMode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hardMode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hardmode_)));
          set_has_hardmode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_openLevel;
        break;
      }

      // optional int32 openLevel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_openLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &openlevel_)));
          set_has_openlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isOpen;
        break;
      }

      // optional bool isOpen = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isOpen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isopen_)));
          set_has_isopen();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_action;
        break;
      }

      // optional int32 action = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &action_)));
          set_has_action();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BountyStage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 hardMode = 2;
  if (has_hardmode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->hardmode(), output);
  }

  // optional int32 openLevel = 3;
  if (has_openlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->openlevel(), output);
  }

  // optional bool isOpen = 4;
  if (has_isopen()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isopen(), output);
  }

  // optional int32 action = 5;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->action(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BountyStage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 hardMode = 2;
  if (has_hardmode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->hardmode(), target);
  }

  // optional int32 openLevel = 3;
  if (has_openlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->openlevel(), target);
  }

  // optional bool isOpen = 4;
  if (has_isopen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->isopen(), target);
  }

  // optional int32 action = 5;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->action(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BountyStage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 hardMode = 2;
    if (has_hardmode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hardmode());
    }

    // optional int32 openLevel = 3;
    if (has_openlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->openlevel());
    }

    // optional bool isOpen = 4;
    if (has_isopen()) {
      total_size += 1 + 1;
    }

    // optional int32 action = 5;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->action());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BountyStage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BountyStage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BountyStage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BountyStage::MergeFrom(const BountyStage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_hardmode()) {
      set_hardmode(from.hardmode());
    }
    if (from.has_openlevel()) {
      set_openlevel(from.openlevel());
    }
    if (from.has_isopen()) {
      set_isopen(from.isopen());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BountyStage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BountyStage::CopyFrom(const BountyStage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BountyStage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BountyStage::Swap(BountyStage* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(hardmode_, other->hardmode_);
    std::swap(openlevel_, other->openlevel_);
    std::swap(isopen_, other->isopen_);
    std::swap(action_, other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BountyStage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BountyStage_descriptor_;
  metadata.reflection = BountyStage_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

// @@protoc_insertion_point(global_scope)
